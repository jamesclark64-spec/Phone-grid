<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OSGB36 Grid + Boundary ‚Üí DXF Export</title>

  <!-- Leaflet -->
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>

  <!-- Geocoder -->
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"/>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <!-- Proj4 + GeoTIFF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.19.0/proj4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>

  <style>
    * { box-sizing: border-box; }
    :root {
      --pad: 14px;
      --radius: 18px;
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      --secondary: #64748b;
      --danger: #dc2626;
      --success: #16a34a;
      --bg-dark: #0f172a;
      --text-light: #f8fafc;
      --border: #e2e8f0;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg-dark);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #map { height: 100%; width: 100%; }

    .leaflet-top, .leaflet-bottom { z-index: 10050 !important; }

    /* Bottom Sheet */
    .sheet {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      z-index: 9999;
      background: rgba(255,255,255,0.98);
      backdrop-filter: blur(10px);
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
      box-shadow: 0 -8px 32px rgba(0,0,0,0.2);

      height: 82vh;
      transform: translateY(48vh);
      transition: transform 220ms cubic-bezier(0.4, 0, 0.2, 1);
      will-change: transform;

      padding: var(--pad);
      padding-bottom: calc(var(--pad) + env(safe-area-inset-bottom));
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .handle {
      width: 48px;
      height: 5px;
      background: #cbd5e1;
      border-radius: 999px;
      margin: 8px auto 16px auto;
      cursor: grab;
      touch-action: none;
      transition: background 150ms;
    }
    
    .handle:hover { background: #94a3b8; }
    .handle:active { cursor: grabbing; }

    .sheet.is-collapsed { overflow: hidden; }
    .sheet.is-collapsed .sheet-content { display: none; }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--border);
    }

    .title {
      font-weight: 800;
      font-size: 18px;
      color: var(--bg-dark);
    }
    
    .status-badge {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      background: var(--primary);
      color: white;
      padding: 6px 12px;
      border-radius: 12px;
      white-space: nowrap;
    }
    
    .status-badge.mode-rotate { background: #7c3aed; }
    .status-badge.mode-boundary { background: #dc2626; }

    /* Sections */
    .section {
      margin-bottom: 20px;
    }
    
    .section-title {
      font-size: 13px;
      font-weight: 700;
      color: var(--secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    /* Button Grid */
    .btn-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
    }

    .btn {
      padding: 14px 16px;
      font-size: 14px;
      font-weight: 700;
      border: none;
      border-radius: 12px;
      background: var(--primary);
      color: white;
      cursor: pointer;
      touch-action: manipulation;
      transition: all 150ms;
      text-align: center;
    }
    
    .btn:hover:not(:disabled) {
      background: var(--primary-dark);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(37,99,235,0.3);
    }
    
    .btn:active:not(:disabled) {
      transform: translateY(0);
    }
    
    .btn.secondary {
      background: var(--secondary);
    }
    
    .btn.secondary:hover:not(:disabled) {
      background: #475569;
    }
    
    .btn.danger {
      background: var(--danger);
    }
    
    .btn.danger:hover:not(:disabled) {
      background: #b91c1c;
    }
    
    .btn.success {
      background: var(--success);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Form Fields */
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

    .field {
      background: #f8fafc;
      border-radius: 12px;
      padding: 12px;
      border: 1px solid var(--border);
    }
    
    .field label {
      display: block;
      font-size: 11px;
      font-weight: 700;
      color: var(--secondary);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 8px;
    }
    
    .field input[type="number"],
    .field input[type="text"] {
      width: 100%;
      font-size: 15px;
      font-weight: 600;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      outline: none;
      background: white;
      transition: border 150ms;
    }
    
    .field input:focus {
      border-color: var(--primary);
    }
    
    .field .value-display {
      font-size: 18px;
      font-weight: 900;
      color: var(--bg-dark);
    }

    /* Toggle Switch */
    .toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 14px;
      gap: 12px;
      margin-bottom: 10px;
    }
    
    .toggle span {
      font-size: 13px;
      font-weight: 600;
      color: var(--bg-dark);
    }
    
    .toggle input[type="checkbox"] {
      width: 48px;
      height: 28px;
      appearance: none;
      background: #cbd5e1;
      border-radius: 14px;
      position: relative;
      cursor: pointer;
      transition: background 150ms;
      flex-shrink: 0;
    }
    
    .toggle input[type="checkbox"]:checked {
      background: var(--primary);
    }
    
    .toggle input[type="checkbox"]::after {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: white;
      top: 3px;
      left: 3px;
      transition: transform 150ms;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .toggle input[type="checkbox"]:checked::after {
      transform: translateX(20px);
    }

    /* Status Messages */
    .status-box {
      margin-top: 16px;
      font-size: 13px;
      color: var(--bg-dark);
      background: #ecfdf5;
      border: 1px solid #a7f3d0;
      padding: 12px;
      border-radius: 12px;
      line-height: 1.5;
    }
    
    .status-box.error {
      background: #fef2f2;
      border-color: #fecaca;
      color: var(--danger);
    }
    
    .status-box.warning {
      background: #fef3c7;
      border-color: #fcd34d;
      color: #92400e;
    }

    .help-text {
      margin-top: 12px;
      font-size: 12px;
      color: var(--secondary);
      line-height: 1.6;
      padding: 10px;
      background: #f1f5f9;
      border-radius: 8px;
    }

    /* Crosshair */
    .crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 40px;
      height: 40px;
      transform: translate(-50%, -50%);
      z-index: 6000;
      pointer-events: none;
      display: none;
    }
    
    .crosshair::before,
    .crosshair::after {
      content: "";
      position: absolute;
      background: rgba(37,99,235,0.9);
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
    }
    
    .crosshair::before {
      left: 50%;
      top: 0;
      width: 3px;
      height: 100%;
      transform: translateX(-50%);
    }
    
    .crosshair::after {
      top: 50%;
      left: 0;
      height: 3px;
      width: 100%;
      transform: translateY(-50%);
    }
    
    .crosshair .dot {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 12px;
      height: 12px;
      border-radius: 999px;
      transform: translate(-50%, -50%);
      background: white;
      border: 3px solid var(--primary);
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
    }

    /* Map Controls */
    .leaflet-control-zoom a {
      width: 44px;
      height: 44px;
      line-height: 44px;
      font-size: 20px;
      border-radius: 10px !important;
    }
    
    .leaflet-control-geocoder {
      max-width: 70vw;
      border-radius: 10px !important;
    }

    /* Grips */
    .grip {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      border: 3px solid var(--primary);
      background: white;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      cursor: grab;
      touch-action: none;
    }
    
    .grip:active { cursor: grabbing; }
    
    .rot-grip {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 3px solid #7c3aed;
      background: white;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      cursor: grab;
      touch-action: none;
      position: relative;
    }
    
    .rot-grip::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: 10px;
      height: 10px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      background: #7c3aed;
    }
    
    .rot-grip:active { cursor: grabbing; }

    /* Coordinates Display */
    .coords-display {
      background: rgba(15, 23, 42, 0.9);
      color: white;
      padding: 8px 14px;
      border-radius: 8px;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      margin-top: 10px;
      display: none;
    }
    
    .coords-display.active { display: block; }

    /* Responsive */
    @media (max-width: 640px) {
      .btn-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div class="crosshair" id="crosshair"><div class="dot"></div></div>

  <div class="sheet" id="sheet">
    <div class="handle" id="handle" aria-label="Drag to resize"></div>

    <div class="header">
      <div class="title">OSGB36 Grid + Boundary</div>
      <div class="status-badge" id="modeBadge">Centre Pick</div>
    </div>

    <div class="sheet-content">
      <!-- Mode Controls -->
      <div class="section">
        <div class="section-title">Mode Controls</div>
        <div class="btn-grid">
          <button class="btn" id="pickCentreBtn">üìç Pick Centre</button>
          <button class="btn secondary" id="pickRotateBtn">üîÑ Pick Rotation</button>
          <button class="btn secondary" id="gpsBtn">üì° Use GPS</button>
          <button class="btn secondary" id="resetBtn">üîÑ Reset All</button>
        </div>
      </div>

      <!-- Boundary Controls -->
      <div class="section">
        <div class="section-title">Boundary Drawing</div>
        <div class="btn-grid">
          <button class="btn secondary" id="drawBoundaryBtn">‚úèÔ∏è Draw Boundary</button>
          <button class="btn success" id="finishBoundaryBtn" disabled>‚úì Finish</button>
          <button class="btn danger" id="clearBoundaryBtn" disabled>‚úó Clear</button>
        </div>
      </div>

      <!-- Options -->
      <div class="section">
        <div class="section-title">Options</div>
        <div class="toggle">
          <span>üéØ Crosshair mode</span>
          <input id="useCrosshair" type="checkbox" />
        </div>
        <div class="toggle">
          <span>üß≠ Auto-align to true north</span>
          <input id="autoNorth" type="checkbox" checked />
        </div>
        <div class="toggle">
          <span>üìê Export relative to centre</span>
          <input id="relativeExport" type="checkbox" />
        </div>
      </div>

      <!-- Grid Parameters -->
      <div class="section">
        <div class="section-title">Grid Parameters</div>
        <div class="form-grid">
          <div class="field">
            <label for="gridWidth">Width (m)</label>
            <input id="gridWidth" type="number" min="1" step="1" value="300" />
          </div>
          <div class="field">
            <label for="gridHeight">Height (m)</label>
            <input id="gridHeight" type="number" min="1" step="1" value="300" />
          </div>
          <div class="field">
            <label for="gridSpacing">Spacing (m)</label>
            <input id="gridSpacing" type="number" min="0.1" step="0.1" value="10" />
          </div>
          <div class="field">
            <label>Rotation</label>
            <div class="value-display" id="rotDeg">0.000¬∞</div>
          </div>
        </div>
      </div>

      <!-- DXF Settings -->
      <div class="section">
        <div class="section-title">DXF Export Settings</div>
        <div class="form-grid">
          <div class="field">
            <label for="layerName">Grid Layer</label>
            <input id="layerName" type="text" value="GRID" />
          </div>
          <div class="field">
            <label for="boundaryLayerName">Boundary Layer</label>
            <input id="boundaryLayerName" type="text" value="BOUNDARY" />
          </div>
        </div>
      </div>

      <!-- Export Button -->
      <div class="section">
        <button class="btn success" id="exportBtn" style="width: 100%; font-size: 16px; padding: 16px;" disabled>
          üì• Export DXF File
        </button>
      </div>

      <!-- Coordinates Display -->
      <div class="coords-display" id="coordsDisplay"></div>

      <!-- Status -->
      <div class="status-box" id="statusBox">Initializing...</div>

      <div class="help-text">
        <strong>Quick Guide:</strong><br>
        ‚Ä¢ Search location using top-right search box<br>
        ‚Ä¢ Pick centre point on map or use GPS<br>
        ‚Ä¢ Drag corner grips to resize, rotate grip to rotate<br>
        ‚Ä¢ Draw boundary by clicking points, then finish<br>
        ‚Ä¢ Export creates DXF with grid (blue) and boundary (red)
      </div>
    </div>
  </div>

<script>
  'use strict';

  // ============================================================================
  // CONFIGURATION & CONSTANTS
  // ============================================================================
  
  const CONFIG = {
    OSTN15_URL: 'https://cdn.proj.org/uk_os_OSTN15_NTv2_OSGBtoETRS.tif',
    EPSG27700_BASE: '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 ' +
                    '+x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs +type=crs',
    DXF_COLORS: { GRID: 5, BOUNDARY: 1 }, // AutoCAD color indices
    DEFAULT_ZOOM: 13,
    GPS_TIMEOUT: 15000,
    TRUE_NORTH_DELTA_LAT: 0.00015 // ~17m for north vector calculation
  };

  const MODES = {
    CENTRE: 'centre',
    ROTATE: 'rotate',
    BOUNDARY: 'boundary'
  };

  // ============================================================================
  // STATE MANAGEMENT
  // ============================================================================
  
  class AppState {
    constructor() {
      this.mode = MODES.CENTRE;
      this.centreLatLng = null;
      this.rotationRad = 0;
      this.userRotatedManually = false;
      this.rotatePt1 = null;
      this.rotatePt2 = null;
      this.boundaryLatLngs = [];
      this.ostnReady = false;
    }

    reset() {
      this.centreLatLng = null;
      this.rotationRad = 0;
      this.userRotatedManually = false;
      this.rotatePt1 = null;
      this.rotatePt2 = null;
      this.boundaryLatLngs = [];
      this.mode = MODES.CENTRE;
    }

    setMode(newMode) {
      this.mode = newMode;
      UI.updateModeBadge(newMode);
    }

    setCentre(latlng) {
      this.centreLatLng = latlng;
      
      if (DOM.autoNorth.checked && !this.userRotatedManually) {
        this.rotationRad = Transforms.calculateTrueNorthRotation(latlng);
      }
    }

    addBoundaryPoint(latlng) {
      this.boundaryLatLngs.push(latlng);
    }

    clearBoundary() {
      this.boundaryLatLngs = [];
    }

    get rotationDegrees() {
      return (this.rotationRad * 180 / Math.PI);
    }
  }

  const state = new AppState();

  // ============================================================================
  // DOM REFERENCES
  // ============================================================================
  
  const DOM = {
    // Controls
    pickCentreBtn: document.getElementById('pickCentreBtn'),
    pickRotateBtn: document.getElementById('pickRotateBtn'),
    gpsBtn: document.getElementById('gpsBtn'),
    resetBtn: document.getElementById('resetBtn'),
    exportBtn: document.getElementById('exportBtn'),
    
    // Boundary
    drawBoundaryBtn: document.getElementById('drawBoundaryBtn'),
    finishBoundaryBtn: document.getElementById('finishBoundaryBtn'),
    clearBoundaryBtn: document.getElementById('clearBoundaryBtn'),
    
    // Toggles
    useCrosshair: document.getElementById('useCrosshair'),
    autoNorth: document.getElementById('autoNorth'),
    relativeExport: document.getElementById('relativeExport'),
    
    // Inputs
    gridWidth: document.getElementById('gridWidth'),
    gridHeight: document.getElementById('gridHeight'),
    gridSpacing: document.getElementById('gridSpacing'),
    layerName: document.getElementById('layerName'),
    boundaryLayerName: document.getElementById('boundaryLayerName'),
    
    // Display
    modeBadge: document.getElementById('modeBadge'),
    rotDeg: document.getElementById('rotDeg'),
    statusBox: document.getElementById('statusBox'),
    crosshair: document.getElementById('crosshair'),
    coordsDisplay: document.getElementById('coordsDisplay'),
    
    // Sheet
    sheet: document.getElementById('sheet'),
    handle: document.getElementById('handle')
  };

  // ============================================================================
  // MAP SETUP
  // ============================================================================
  
  const map = L.map('map', { zoomControl: true })
    .setView([52.2, 0.9], CONFIG.DEFAULT_ZOOM);

  L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { maxZoom: 20, attribution: 'Tiles ¬© Esri' }
  ).addTo(map);

  const geocodeControl = L.Control.geocoder({ defaultMarkGeocode: false }).addTo(map);
  geocodeControl.on('markgeocode', (e) => {
    map.fitBounds(e.geocode.bbox);
  });

  // Map layers
  const layers = {
    grid: L.layerGroup().addTo(map),
    grips: L.layerGroup().addTo(map),
    boundaryPoints: L.layerGroup().addTo(map),
    centreMarker: null,
    rotateMarkers: [],
    boundaryLine: null,
    gpsAccuracy: null
  };

  // ============================================================================
  // COORDINATE TRANSFORMS
  // ============================================================================
  
  proj4.defs('EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs +type=crs');

  const Transforms = {
    latLngToEN(latlng) {
      const out = proj4('EPSG:4326', 'EPSG:27700', [latlng.lng, latlng.lat]);
      return { e: out[0], n: out[1] };
    },

    enToLatLng(e, n) {
      const out = proj4('EPSG:27700', 'EPSG:4326', [e, n]);
      return L.latLng(out[1], out[0]);
    },

    rotatePoint(e, n, centreE, centreN, angle) {
      const dE = e - centreE;
      const dN = n - centreN;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        e: centreE + dE * cos - dN * sin,
        n: centreN + dE * sin + dN * cos
      };
    },

    rotateVector(e, n, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        e: e * cos - n * sin,
        n: e * sin + n * cos
      };
    },

    calculateTrueNorthRotation(latlng) {
      const p0 = this.latLngToEN(latlng);
      const pN = this.latLngToEN(
        L.latLng(latlng.lat + CONFIG.TRUE_NORTH_DELTA_LAT, latlng.lng)
      );
      const dE = pN.e - p0.e;
      const dN = pN.n - p0.n;
      const angleFromEast = Math.atan2(dN, dE);
      return angleFromEast - (Math.PI / 2);
    }
  };

  // ============================================================================
  // GRID GENERATION
  // ============================================================================
  
  const GridGenerator = {
    generateLines(centreEN, width, height, spacing, rotation) {
      const halfW = width / 2;
      const halfH = height / 2;

      const stepsX = Math.max(1, Math.round(width / spacing));
      const stepsY = Math.max(1, Math.round(height / spacing));
      const stepX = width / stepsX;
      const stepY = height / stepsY;

      const lines = [];

      // Vertical lines
      for (let i = 0; i <= stepsX; i++) {
        const x = -halfW + i * stepX;
        const p1 = Transforms.rotatePoint(
          centreEN.e + x, centreEN.n - halfH,
          centreEN.e, centreEN.n, rotation
        );
        const p2 = Transforms.rotatePoint(
          centreEN.e + x, centreEN.n + halfH,
          centreEN.e, centreEN.n, rotation
        );
        lines.push({ e1: p1.e, n1: p1.n, e2: p2.e, n2: p2.n });
      }

      // Horizontal lines
      for (let j = 0; j <= stepsY; j++) {
        const y = -halfH + j * stepY;
        const p1 = Transforms.rotatePoint(
          centreEN.e - halfW, centreEN.n + y,
          centreEN.e, centreEN.n, rotation
        );
        const p2 = Transforms.rotatePoint(
          centreEN.e + halfW, centreEN.n + y,
          centreEN.e, centreEN.n, rotation
        );
        lines.push({ e1: p1.e, n1: p1.n, e2: p2.e, n2: p2.n });
      }

      return lines;
    }
  };

  // ============================================================================
  // DXF EXPORT
  // ============================================================================
  
  const DXFExporter = {
    createLineEntity(x1, y1, x2, y2, layer, color) {
      return [
        "0", "LINE",
        "8", layer,
        "62", String(color),
        "10", x1.toFixed(3),
        "20", y1.toFixed(3),
        "30", "0.000",
        "11", x2.toFixed(3),
        "21", y2.toFixed(3),
        "31", "0.000"
      ].join("\n") + "\n";
    },

    createPolyline(points, layer, color, closed = false) {
      let dxf = "0\nLWPOLYLINE\n";
      dxf += `8\n${layer}\n`;
      dxf += `62\n${color}\n`;
      dxf += `90\n${points.length}\n`;
      dxf += `70\n${closed ? 1 : 0}\n`;
      
      for (const p of points) {
        dxf += `10\n${p.x.toFixed(3)}\n`;
        dxf += `20\n${p.y.toFixed(3)}\n`;
      }
      
      return dxf;
    },

    export() {
      if (!state.centreLatLng) {
        UI.showError("Please pick a centre point first");
        return;
      }

      const width = parseFloat(DOM.gridWidth.value);
      const height = parseFloat(DOM.gridHeight.value);
      const spacing = parseFloat(DOM.gridSpacing.value);

      if (!(width > 0) || !(height > 0) || !(spacing > 0)) {
        UI.showError("Width, height and spacing must be greater than 0");
        return;
      }

      const gridLayer = (DOM.layerName.value || "GRID").trim();
      const boundaryLayer = (DOM.boundaryLayerName.value || "BOUNDARY").trim();
      const relative = DOM.relativeExport.checked;

      const centreEN = Transforms.latLngToEN(state.centreLatLng);
      const linesEN = GridGenerator.generateLines(
        centreEN, width, height, spacing, state.rotationRad
      );

      // Convert to DXF coordinates
      const lines = linesEN.map(l => relative ? {
        x1: l.e1 - centreEN.e, y1: l.n1 - centreEN.n,
        x2: l.e2 - centreEN.e, y2: l.n2 - centreEN.n
      } : {
        x1: l.e1, y1: l.n1,
        x2: l.e2, y2: l.n2
      });

      // Convert boundary
      let boundaryPoints = null;
      if (state.boundaryLatLngs.length >= 2) {
        boundaryPoints = state.boundaryLatLngs.map(ll => {
          const en = Transforms.latLngToEN(ll);
          return relative ? 
            { x: en.e - centreEN.e, y: en.n - centreEN.n } :
            { x: en.e, y: en.n };
        });
      }

      // Build DXF
      let dxf = "0\nSECTION\n2\nHEADER\n";
      dxf += "9\n$INSUNITS\n70\n6\n"; // Meters
      dxf += "0\nENDSEC\n";
      dxf += "0\nSECTION\n2\nENTITIES\n";

      // Add grid lines
      for (const ln of lines) {
        dxf += this.createLineEntity(
          ln.x1, ln.y1, ln.x2, ln.y2,
          gridLayer, CONFIG.DXF_COLORS.GRID
        );
      }

      // Add boundary
      if (boundaryPoints) {
        dxf += this.createPolyline(
          boundaryPoints, boundaryLayer,
          CONFIG.DXF_COLORS.BOUNDARY, false
        );
      }

      dxf += "0\nENDSEC\n0\nEOF\n";

      // Download
      const blob = new Blob([dxf], { type: "application/dxf" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      
      const deg = state.rotationDegrees.toFixed(1);
      const coords = relative ? "REL" : "OSGB";
      a.download = `grid_${coords}_${width}x${height}_${spacing}m_${deg}deg.dxf`;
      a.href = url;
      a.style.display = "none";
      
      document.body.appendChild(a);
      a.click();
      
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);

      UI.showSuccess("DXF exported successfully!");
    }
  };

  // ============================================================================
  // UI MANAGEMENT
  // ============================================================================
  
  const UI = {
    updateModeBadge(mode) {
      DOM.modeBadge.textContent = 
        mode === MODES.CENTRE ? 'Centre Pick' :
        mode === MODES.ROTATE ? 'Rotation Pick' :
        'Boundary Draw';
      
      DOM.modeBadge.className = 'status-badge';
      if (mode === MODES.ROTATE) DOM.modeBadge.classList.add('mode-rotate');
      if (mode === MODES.BOUNDARY) DOM.modeBadge.classList.add('mode-boundary');
    },

    updateRotationDisplay() {
      DOM.rotDeg.textContent = state.rotationDegrees.toFixed(3) + '¬∞';
    },

    updateCoordinatesDisplay(latlng) {
      if (!latlng) {
        DOM.coordsDisplay.classList.remove('active');
        return;
      }

      const en = Transforms.latLngToEN(latlng);
      DOM.coordsDisplay.classList.add('active');
      DOM.coordsDisplay.textContent = 
        `E: ${en.e.toFixed(2)}m  N: ${en.n.toFixed(2)}m  ` +
        `Lat: ${latlng.lat.toFixed(6)}¬∞  Lng: ${latlng.lng.toFixed(6)}¬∞`;
    },

    showStatus(message, type = 'success') {
      DOM.statusBox.textContent = message;
      DOM.statusBox.className = 'status-box';
      if (type === 'error') DOM.statusBox.classList.add('error');
      if (type === 'warning') DOM.statusBox.classList.add('warning');
    },

    showSuccess(message) {
      this.showStatus(message, 'success');
    },

    showError(message) {
      this.showStatus(message, 'error');
      alert(message);
    },

    showWarning(message) {
      this.showStatus(message, 'warning');
    },

    updateBoundaryButtons() {
      const hasPoints = state.boundaryLatLngs.length > 0;
      const canFinish = state.boundaryLatLngs.length >= 2;
      
      DOM.finishBoundaryBtn.disabled = !canFinish;
      DOM.clearBoundaryBtn.disabled = !hasPoints;
      
      if (state.mode === MODES.BOUNDARY) {
        DOM.drawBoundaryBtn.textContent = '‚úèÔ∏è Drawing... (click map)';
      } else {
        DOM.drawBoundaryBtn.textContent = '‚úèÔ∏è Draw Boundary';
      }
    }
  };

  // ============================================================================
  // RENDERING
  // ============================================================================
  
  const Renderer = {
    clearAll() {
      layers.grid.clearLayers();
      layers.grips.clearLayers();
      layers.boundaryPoints.clearLayers();
      if (layers.boundaryLine) {
        layers.boundaryLine.remove();
        layers.boundaryLine = null;
      }
    },

    redrawGrid() {
      layers.grid.clearLayers();
      
      if (!state.centreLatLng) return;

      const width = parseFloat(DOM.gridWidth.value);
      const height = parseFloat(DOM.gridHeight.value);
      const spacing = parseFloat(DOM.gridSpacing.value);

      if (!(width > 0) || !(height > 0) || !(spacing > 0)) return;

      const centreEN = Transforms.latLngToEN(state.centreLatLng);
      const lines = GridGenerator.generateLines(
        centreEN, width, height, spacing, state.rotationRad
      );

      for (const ln of lines) {
        const a = Transforms.enToLatLng(ln.e1, ln.n1);
        const b = Transforms.enToLatLng(ln.e2, ln.n2);
        L.polyline([a, b], {
          color: '#2563eb',
          weight: 2,
          opacity: 0.8
        }).addTo(layers.grid);
      }
    },

    redrawGrips() {
      layers.grips.clearLayers();
      
      if (!state.centreLatLng) return;

      const width = parseFloat(DOM.gridWidth.value);
      const height = parseFloat(DOM.gridHeight.value);

      if (!(width > 0) || !(height > 0)) return;

      const centreEN = Transforms.latLngToEN(state.centreLatLng);
      const halfW = width / 2;
      const halfH = height / 2;

      // Corner grips
      const corners = [
        { x: -halfW, y: -halfH },
        { x: halfW, y: -halfH },
        { x: halfW, y: halfH },
        { x: -halfW, y: halfH }
      ];

      corners.forEach(corner => {
        const p = Transforms.rotatePoint(
          centreEN.e + corner.x,
          centreEN.n + corner.y,
          centreEN.e, centreEN.n,
          state.rotationRad
        );
        const ll = Transforms.enToLatLng(p.e, p.n);

        const marker = L.marker(ll, {
          draggable: true,
          icon: L.divIcon({
            className: '',
            html: '<div class="grip"></div>',
            iconSize: [28, 28],
            iconAnchor: [14, 14]
          }),
          keyboard: false,
          autoPan: true,
          autoPanPadding: [50, 50]
        }).addTo(layers.grips);

        this.preventGestureConflicts(marker);
        this.setupCornerGripDrag(marker);
      });

      // Rotation grip
      const rotOffset = Math.max(halfH * 1.3, 15);
      const rotP = Transforms.rotatePoint(
        centreEN.e,
        centreEN.n + rotOffset,
        centreEN.e, centreEN.n,
        state.rotationRad
      );
      const rotLL = Transforms.enToLatLng(rotP.e, rotP.n);

      const rotMarker = L.marker(rotLL, {
        draggable: true,
        icon: L.divIcon({
          className: '',
          html: '<div class="rot-grip"></div>',
          iconSize: [32, 32],
          iconAnchor: [16, 16]
        }),
        keyboard: false,
        autoPan: true,
        autoPanPadding: [50, 50]
      }).addTo(layers.grips);

      this.preventGestureConflicts(rotMarker);
      this.setupRotationGripDrag(rotMarker);
    },

    redrawBoundary() {
      layers.boundaryPoints.clearLayers();
      if (layers.boundaryLine) {
        layers.boundaryLine.remove();
        layers.boundaryLine = null;
      }

      if (state.boundaryLatLngs.length === 0) return;

      // Draw line
      layers.boundaryLine = L.polyline(state.boundaryLatLngs, {
        color: '#dc2626',
        weight: 3,
        opacity: 0.9
      }).addTo(map);

      // Draw points
      state.boundaryLatLngs.forEach(ll => {
        L.circleMarker(ll, {
          radius: 6,
          color: '#dc2626',
          weight: 3,
          opacity: 0.9,
          fillColor: 'white',
          fillOpacity: 0.9
        }).addTo(layers.boundaryPoints);
      });
    },

    redrawAll() {
      this.redrawGrid();
      this.redrawGrips();
      this.redrawBoundary();
      UI.updateRotationDisplay();
      UI.updateBoundaryButtons();
    },

    preventGestureConflicts(marker) {
      marker.on('add', () => {
        const el = marker.getElement();
        if (!el) return;

        L.DomEvent.disableClickPropagation(el);
        L.DomEvent.disableScrollPropagation(el);

        const stop = (e) => L.DomEvent.stopPropagation(e);
        ['pointerdown', 'pointermove', 'pointerup',
         'touchstart', 'touchmove', 'touchend',
         'mousedown', 'mousemove', 'mouseup']
          .forEach(evt => L.DomEvent.on(el, evt, stop));
      });
    },

    setupCornerGripDrag(marker) {
      marker.on('dragstart', () => {
        map.dragging.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.touchZoom.disable();
      });

      marker.on('dragend', () => {
        map.dragging.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.touchZoom.enable();
      });

      marker.on('drag', () => {
        // Get fresh centre coordinates each time
        const centreEN = Transforms.latLngToEN(state.centreLatLng);
        const p = Transforms.latLngToEN(marker.getLatLng());
        const dE = p.e - centreEN.e;
        const dN = p.n - centreEN.n;

        const local = Transforms.rotateVector(dE, dN, -state.rotationRad);

        const newHalfW = Math.max(1, Math.abs(local.e));
        const newHalfH = Math.max(1, Math.abs(local.n));

        DOM.gridWidth.value = Math.round(newHalfW * 2);
        DOM.gridHeight.value = Math.round(newHalfH * 2);

        this.redrawAll();
      });
    },

    setupRotationGripDrag(marker) {
      marker.on('dragstart', () => {
        state.userRotatedManually = true;
        map.dragging.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.touchZoom.disable();
      });

      marker.on('dragend', () => {
        map.dragging.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.touchZoom.enable();
      });

      marker.on('drag', () => {
        // Get fresh centre coordinates each time
        const centreEN = Transforms.latLngToEN(state.centreLatLng);
        const p = Transforms.latLngToEN(marker.getLatLng());
        const dE = p.e - centreEN.e;
        const dN = p.n - centreEN.n;
        const angleFromEast = Math.atan2(dN, dE);
        state.rotationRad = angleFromEast - (Math.PI / 2);
        this.redrawAll();
      });
    }
  };

  // ============================================================================
  // MAP INTERACTIONS
  // ============================================================================
  
  const MapInteraction = {
    getCrosshairOrClick(clickLatLng) {
      return DOM.useCrosshair.checked ? map.getCenter() : clickLatLng;
    },

    handleMapClick(e) {
      const latlng = this.getCrosshairOrClick(e.latlng);

      switch (state.mode) {
        case MODES.BOUNDARY:
          state.addBoundaryPoint(latlng);
          Renderer.redrawBoundary();
          UI.updateBoundaryButtons();
          break;

        case MODES.CENTRE:
          this.setCentre(latlng);
          break;

        case MODES.ROTATE:
          this.handleRotatePick(latlng);
          break;
      }
    },

    setCentre(latlng) {
      state.setCentre(latlng);

      // Update or create centre marker
      if (layers.centreMarker) {
        layers.centreMarker.setLatLng(latlng);
      } else {
        layers.centreMarker = L.marker(latlng, {
          draggable: true,
          icon: L.icon({
            iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNSIgaGVpZ2h0PSI0MSI+PHBhdGggZD0iTTEyLjUgMEMxOS40MDQgMCAyNSA1LjU5NiAyNSAxMi41IDI1IDE5LjQwNCAxMi41IDQxIDEyLjUgNDFTMCAyMS40MDQgMCAxMi41QzAgNS41OTYgNS41OTYgMCAxMi41IDB6IiBmaWxsPSIjMjU2M2ViIi8+PGNpcmNsZSBjeD0iMTIuNSIgY3k9IjEyLjUiIHI9IjUiIGZpbGw9IiNmZmYiLz48L3N2Zz4=',
            iconSize: [25, 41],
            iconAnchor: [12.5, 41]
          })
        }).addTo(map);

        layers.centreMarker.on('drag', () => {
          state.setCentre(layers.centreMarker.getLatLng());
          Renderer.redrawAll();
          UI.updateCoordinatesDisplay(state.centreLatLng);
        });
      }

      Renderer.redrawAll();
      UI.updateCoordinatesDisplay(latlng);
      UI.showSuccess('Centre point set');
      DOM.exportBtn.disabled = false;
    },

    handleRotatePick(latlng) {
      state.userRotatedManually = true;

      if (!state.rotatePt1) {
        state.rotatePt1 = latlng;
        const m = L.circleMarker(latlng, {
          radius: 8,
          color: '#7c3aed',
          weight: 3,
          fillColor: 'white',
          fillOpacity: 0.9
        }).addTo(map);
        layers.rotateMarkers.push(m);
        UI.showStatus('Click second point to set rotation', 'warning');
        return;
      }

      if (!state.rotatePt2) {
        state.rotatePt2 = latlng;
        const m = L.circleMarker(latlng, {
          radius: 8,
          color: '#7c3aed',
          weight: 3,
          fillColor: 'white',
          fillOpacity: 0.9
        }).addTo(map);
        layers.rotateMarkers.push(m);

        // Calculate rotation
        const p1 = Transforms.latLngToEN(state.rotatePt1);
        const p2 = Transforms.latLngToEN(state.rotatePt2);
        const angleFromEast = Math.atan2(p2.n - p1.n, p2.e - p1.e);
        state.rotationRad = angleFromEast - (Math.PI / 2);

        Renderer.redrawAll();
        UI.showSuccess('Rotation set');

        // Reset for next rotation
        state.rotatePt1 = null;
        state.rotatePt2 = null;
      }
    }
  };

  // ============================================================================
  // EVENT HANDLERS
  // ============================================================================
  
  // Map events
  map.on('click', (e) => MapInteraction.handleMapClick(e));

  map.on('mousemove', (e) => {
    if (DOM.useCrosshair.checked) {
      UI.updateCoordinatesDisplay(e.latlng);
    }
  });

  map.on('locationfound', (e) => {
    MapInteraction.setCentre(e.latlng);
    
    if (layers.gpsAccuracy) layers.gpsAccuracy.remove();
    layers.gpsAccuracy = L.circle(e.latlng, {
      radius: e.accuracy,
      color: '#16a34a',
      weight: 2,
      opacity: 0.6,
      fillOpacity: 0.1
    }).addTo(map);

    map.setView(e.latlng, 18);
  });

  map.on('locationerror', (e) => {
    UI.showError('GPS location failed: ' + (e.message || 'Permission denied'));
  });

  // Button events
  DOM.pickCentreBtn.addEventListener('click', () => {
    state.setMode(MODES.CENTRE);
    if (DOM.useCrosshair.checked) {
      MapInteraction.setCentre(map.getCenter());
    } else {
      UI.showStatus('Click on map to set centre point');
    }
  });

  DOM.pickRotateBtn.addEventListener('click', () => {
    state.setMode(MODES.ROTATE);
    state.rotatePt1 = null;
    state.rotatePt2 = null;
    layers.rotateMarkers.forEach(m => m.remove());
    layers.rotateMarkers = [];
    UI.showStatus('Click two points to set rotation angle');
  });

  DOM.gpsBtn.addEventListener('click', () => {
    UI.showStatus('Getting GPS location...');
    map.locate({
      setView: true,
      maxZoom: 18,
      enableHighAccuracy: true,
      timeout: CONFIG.GPS_TIMEOUT
    });
  });

  DOM.resetBtn.addEventListener('click', () => {
    if (!confirm('Reset all? This will clear centre, rotation, and boundary.')) return;

    state.reset();
    
    if (layers.centreMarker) {
      layers.centreMarker.remove();
      layers.centreMarker = null;
    }
    
    layers.rotateMarkers.forEach(m => m.remove());
    layers.rotateMarkers = [];
    
    if (layers.gpsAccuracy) {
      layers.gpsAccuracy.remove();
      layers.gpsAccuracy = null;
    }

    Renderer.clearAll();
    UI.updateRotationDisplay();
    UI.updateBoundaryButtons();
    UI.updateCoordinatesDisplay(null);
    UI.showStatus('Reset complete');
    DOM.exportBtn.disabled = true;
  });

  DOM.drawBoundaryBtn.addEventListener('click', () => {
    state.setMode(MODES.BOUNDARY);
    UI.showStatus('Click points on map to draw boundary');
  });

  DOM.finishBoundaryBtn.addEventListener('click', () => {
    state.setMode(MODES.CENTRE);
    UI.showSuccess(`Boundary complete with ${state.boundaryLatLngs.length} points`);
  });

  DOM.clearBoundaryBtn.addEventListener('click', () => {
    if (!confirm('Clear boundary?')) return;
    
    state.clearBoundary();
    Renderer.redrawBoundary();
    UI.updateBoundaryButtons();
    state.setMode(MODES.CENTRE);
    UI.showStatus('Boundary cleared');
  });

  DOM.exportBtn.addEventListener('click', () => DXFExporter.export());

  // Input events
  [DOM.gridWidth, DOM.gridHeight, DOM.gridSpacing].forEach(input => {
    input.addEventListener('input', () => Renderer.redrawAll());
  });

  DOM.autoNorth.addEventListener('change', () => {
    if (state.centreLatLng && DOM.autoNorth.checked && !state.userRotatedManually) {
      state.rotationRad = Transforms.calculateTrueNorthRotation(state.centreLatLng);
      Renderer.redrawAll();
    }
  });

  DOM.useCrosshair.addEventListener('change', () => {
    DOM.crosshair.style.display = DOM.useCrosshair.checked ? 'block' : 'none';
    if (DOM.useCrosshair.checked) {
      UI.showStatus('Crosshair mode active - map centre will be used');
    }
  });

  // ============================================================================
  // BOTTOM SHEET INTERACTION
  // ============================================================================
  
  const Sheet = {
    snaps: { open: 8, half: 48, closed: 70 },
    current: 'half',
    dragging: false,
    startY: 0,
    startVh: 48,

    init() {
      this.setSnap('half');
      
      DOM.handle.addEventListener('click', () => {
        this.setSnap(this.current === 'closed' ? 'half' : 'closed');
      });

      DOM.handle.addEventListener('pointerdown', (e) => {
        this.dragging = true;
        DOM.handle.setPointerCapture(e.pointerId);
        DOM.sheet.style.transition = 'none';
        this.startY = e.clientY;
        this.startVh = this.getCurrentVh();
      });

      DOM.handle.addEventListener('pointermove', (e) => {
        if (!this.dragging) return;

        const dyPx = e.clientY - this.startY;
        const vhPx = window.innerHeight / 100;
        const dyVh = dyPx / vhPx;
        const nextVh = Math.max(0, Math.min(75, this.startVh + dyVh));
        
        DOM.sheet.style.transform = `translateY(${nextVh}vh)`;
      });

      DOM.handle.addEventListener('pointerup', () => {
        if (!this.dragging) return;
        this.dragging = false;
        DOM.sheet.style.transition = 'transform 220ms cubic-bezier(0.4, 0, 0.2, 1)';

        const currentVh = this.getCurrentVh();
        const snapEntries = Object.entries(this.snaps);
        let closest = snapEntries[0];
        
        for (const entry of snapEntries) {
          if (Math.abs(entry[1] - currentVh) < Math.abs(closest[1] - currentVh)) {
            closest = entry;
          }
        }
        
        this.setSnap(closest[0]);
      });
    },

    setSnap(snap) {
      this.current = snap;
      DOM.sheet.style.transform = `translateY(${this.snaps[snap]}vh)`;
      DOM.sheet.classList.toggle('is-collapsed', snap === 'closed');
    },

    getCurrentVh() {
      const match = DOM.sheet.style.transform.match(/translateY\(([-0-9.]+)vh\)/);
      return match ? parseFloat(match[1]) : this.snaps.half;
    }
  };

  Sheet.init();

  // ============================================================================
  // OSTN15 INITIALIZATION
  // ============================================================================
  
  async function initializeOSTN15() {
    try {
      UI.showStatus('Loading OSTN15 grid shift (requires internet)...');
      
      const tiff = await GeoTIFF.fromUrl(CONFIG.OSTN15_URL);
      await proj4.nadgrid('OSTN15_NTv2_OSGBtoETRS', tiff).ready;

      proj4.defs('EPSG:27700', CONFIG.EPSG27700_BASE + ' +nadgrids=OSTN15_NTv2_OSGBtoETRS');
      state.ostnReady = true;
      
      UI.showSuccess('‚úì OSTN15 loaded - OSGB36(15) coordinate system ready');
      DOM.exportBtn.disabled = false;

      if (state.centreLatLng && DOM.autoNorth.checked && !state.userRotatedManually) {
        state.rotationRad = Transforms.calculateTrueNorthRotation(state.centreLatLng);
        Renderer.redrawAll();
      }
    } catch (error) {
      console.error('OSTN15 load failed:', error);
      
      UI.showWarning(
        '‚ö† OSTN15 unavailable - using fallback transformation (¬±5m accuracy). ' +
        'Host via HTTPS for survey-grade accuracy.'
      );
      
      proj4.defs(
        'EPSG:27700',
        CONFIG.EPSG27700_BASE +
        ' +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489'
      );
      
      state.ostnReady = false;
      DOM.exportBtn.disabled = false;
    }
  }

  // ============================================================================
  // ERROR HANDLING
  // ============================================================================
  
  window.addEventListener('error', (event) => {
    console.error('Runtime error:', event.error);
    UI.showError('Error: ' + (event.message || 'Unknown error occurred'));
  });

  window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    UI.showError('Async error: ' + (event.reason?.message || 'Unknown error'));
  });

  // ============================================================================
  // STARTUP
  // ============================================================================
  
  (async function initialize() {
    UI.updateRotationDisplay();
    UI.updateBoundaryButtons();
    UI.showStatus('Initializing...');
    
    await initializeOSTN15();
    
    UI.showStatus('Ready! Search for location or click map to begin.');
  })();

</script>
</body>
</html>
