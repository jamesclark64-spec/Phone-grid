<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>SurveyGrid Pro</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; overflow: hidden; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; z-index: 1; }
        
        .ui-panel {
            position: absolute; bottom: 20px; left: 10px; right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            display: flex; flex-direction: column; gap: 10px;
            max-height: 30vh; overflow-y: auto;
        }

        .tool-bar {
            position: absolute; top: 10px; right: 10px;
            z-index: 1000; display: flex; flex-direction: column; gap: 8px;
        }

        button {
            background: #007AFF; color: white; border: none; padding: 12px;
            border-radius: 8px; font-weight: 600; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        button.active { background: #34C759; }
        
        .input-group { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
        label { font-size: 14px; font-weight: 500; color: #333; }
        input[type="number"] { width: 60px; padding: 8px; border: 1px solid #ccc; border-radius: 6px; }

        /* Grip Styles */
        .grip-icon {
            background: white; border: 2px solid #007AFF;
            border-radius: 50%; box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: border-color 0.2s;
        }
        .grip-center { background: rgba(255,0,0,0.5); border: 2px solid white; cursor: move; }
        .grip-rotate { border-color: #FF9500; cursor: grab; }
        .grip-resize { border-color: #34C759; cursor: nwse-resize; }

    </style>
</head>
<body>

    <div id="map"></div>

    <div class="tool-bar">
        <button onclick="locateUser()">üìç GPS</button>
        <button onclick="toggleBoundaryMode()" id="btn-boundary">‚úèÔ∏è Draw Boundary</button>
        <button onclick="resetRotation()">‚¨ÜÔ∏è True North</button>
    </div>

    <div class="ui-panel">
        <div class="input-group">
            <label>Grid Spacing (m)</label>
            <input type="number" id="gridSpacing" value="10" onchange="updateGridFromInput()">
        </div>
        <div class="input-group">
            <label>Width (m)</label>
            <input type="number" id="gridWidth" value="300" onchange="updateGridFromInput()">
        </div>
        <div class="input-group">
            <label>Height (m)</label>
            <input type="number" id="gridHeight" value="300" onchange="updateGridFromInput()">
        </div>
        <button onclick="exportDXF()">üíæ Export DXF</button>
        <div id="status" style="font-size: 11px; color: #666; text-align: center;">Drag grips to adjust grid.</div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

    <script>
        // --- SETUP & CONFIG ---
        proj4.defs("EPSG:27700","+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs");
        
        const map = L.map('map').setView([51.505, -0.09], 16);
        
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri', maxZoom: 21
        }).addTo(map);

        L.Control.geocoder({ defaultMarkGeocode: false })
        .on('markgeocode', function(e) {
            map.setView(e.geocode.center, 18);
            moveGridTo(e.geocode.center);
        }).addTo(map);

        // --- STATE ---
        let gridState = {
            center: map.getCenter(),
            width: 300,
            height: 300,
            rotation: 0, // Radians
            spacing: 10
        };

        const gridLayer = L.layerGroup().addTo(map); // For lines
        const boundaryLayer = L.layerGroup().addTo(map); // For boundary polygon
        
        // --- GRIP INITIALIZATION (Create once, move later) ---
        // We do NOT clear these layers. We just move markers.
        
        const gripIconSize = [20, 20];
        
        // 1. Center Grip
        const centerGrip = L.marker(gridState.center, {
            draggable: true,
            zIndexOffset: 1000,
            icon: L.divIcon({className: 'grip-icon grip-center', iconSize: gripIconSize})
        }).addTo(map);

        // 2. Rotate Grip (Top Right)
        const rotateGrip = L.marker(gridState.center, {
            draggable: true,
            zIndexOffset: 1000,
            icon: L.divIcon({className: 'grip-icon grip-rotate', iconSize: gripIconSize})
        }).addTo(map);

        // 3. Resize Grip (Top Left)
        const resizeGrip = L.marker(gridState.center, {
            draggable: true,
            zIndexOffset: 1000,
            icon: L.divIcon({className: 'grip-icon grip-resize', iconSize: gripIconSize})
        }).addTo(map);

        // --- MATH HELPERS ---
        function getCorners() {
            const w = gridState.width;
            const h = gridState.height;
            const c = gridState.center;
            const r = gridState.rotation;
            
            // Convert to meters logic is simplified for UI, precise for DXF
            // 1 deg Lat ~ 111132m
            const mLat = 1/111132;
            const mLng = 1/(111320 * Math.cos(c.lat * Math.PI/180));
            
            const cos = Math.cos(r);
            const sin = Math.sin(r);

            const offsets = [
                {x: -w/2, y: h/2}, // TL (Resize Grip)
                {x: w/2, y: h/2},  // TR (Rotate Grip)
                {x: w/2, y: -h/2}, // BR
                {x: -w/2, y: -h/2} // BL
            ];

            return offsets.map(o => {
                const rx = o.x * cos - o.y * sin;
                const ry = o.x * sin + o.y * cos;
                return L.latLng(c.lat + ry * mLat, c.lng + rx * mLng);
            });
        }

        // --- MAIN RENDER LOOP ---
        function renderGrid() {
            gridLayer.clearLayers();
            const corners = getCorners();

            // 1. Draw Outline
            L.polygon(corners, {color: '#007AFF', weight: 2, fill: false}).addTo(gridLayer);

            // 2. Draw Internal Grid
            const stepsX = Math.floor(gridState.width / gridState.spacing);
            const stepsY = Math.floor(gridState.height / gridState.spacing);

            const lerp = (p1, p2, t) => L.latLng(
                p1.lat + (p2.lat - p1.lat) * t,
                p1.lng + (p2.lng - p1.lng) * t
            );

            // Vertical Lines (Interpolate Bottom-Left to Bottom-Right AND Top-Left to Top-Right)
            // Corners: 0=TL, 1=TR, 2=BR, 3=BL
            // Careful with order from getCorners: 0:TL, 1:TR, 2:BR, 3:BL
            
            for(let i=1; i<=stepsX; i++) {
                const t = (i * gridState.spacing) / gridState.width;
                const p1 = lerp(corners[3], corners[2], t); // Bottom Edge
                const p2 = lerp(corners[0], corners[1], t); // Top Edge
                L.polyline([p1, p2], {color: '#007AFF', weight: 1, opacity: 0.4}).addTo(gridLayer);
            }

            for(let i=1; i<=stepsY; i++) {
                const t = (i * gridState.spacing) / gridState.height;
                const p1 = lerp(corners[3], corners[0], t); // Left Edge
                const p2 = lerp(corners[2], corners[1], t); // Right Edge
                L.polyline([p1, p2], {color: '#007AFF', weight: 1, opacity: 0.4}).addTo(gridLayer);
            }

            // 3. Move Grips (Only if not being dragged)
            // We use flags to check if a specific grip is currently active
            if(!centerGrip.dragging.enabled() || !centerGrip._dragging) centerGrip.setLatLng(gridState.center);
            
            // TR is Rotate, TL is Resize
            if(!isDraggingRotate) rotateGrip.setLatLng(corners[1]); 
            if(!isDraggingResize) resizeGrip.setLatLng(corners[0]);
        }

        // --- DRAG HANDLERS ---
        
        let isDraggingRotate = false;
        let isDraggingResize = false;

        // 1. Center Grip Logic
        centerGrip.on('drag', (e) => {
            gridState.center = e.latlng;
            renderGrid();
        });
        centerGrip.on('dragend', (e) => {
            gridState.center = e.latlng;
            renderGrid(); // Snaps other grips to final spot
        });

        // 2. Rotate Grip Logic
        rotateGrip.on('dragstart', () => { isDraggingRotate = true; });
        rotateGrip.on('drag', (e) => {
            const center = map.latLngToLayerPoint(gridState.center);
            const mouse = map.latLngToLayerPoint(e.latlng);
            
            // Calculate angle
            const dx = mouse.x - center.x;
            const dy = mouse.y - center.y; // Leaflet Y increases downwards
            
            // Visual rotation (screen space)
            // At 0 rotation, TR corner is at angle -45 deg (top right) in screen coords?
            // Let's use simple atan2. 
            // We want the angle relative to "East".
            // Standard Math.atan2(y, x) gives radians.
            
            // Correction: We just want the delta angle.
            // Let's assume the TR corner is naturally at -45deg (or -PI/4).
            const currentAngle = Math.atan2(dy, dx);
            // Offset so that dragging it "up" makes it 0.
            gridState.rotation = currentAngle + (Math.PI/4); // Tweaked for feel
            
            renderGrid();
        });
        rotateGrip.on('dragend', () => { 
            isDraggingRotate = false; 
            renderGrid(); // Snaps grip back to perfect corner
        });

        // 3. Resize Grip Logic
        resizeGrip.on('dragstart', () => { isDraggingResize = true; });
        resizeGrip.on('drag', (e) => {
            const dist = map.distance(gridState.center, e.latlng);
            // Assume square resize for simplicity or user sanity
            // Distance from center to corner is sqrt(w^2 + h^2)/2
            // If square: dist = w * sqrt(2) / 2
            // So w = dist * 2 / sqrt(2) = dist * sqrt(2)
            const size = dist * 1.4142;
            
            // Clamp min size
            if(size > 10) {
                gridState.width = Math.round(size);
                gridState.height = Math.round(size);
                
                // Update inputs
                document.getElementById('gridWidth').value = gridState.width;
                document.getElementById('gridHeight').value = gridState.height;
            }
            renderGrid();
        });
        resizeGrip.on('dragend', () => { 
            isDraggingResize = false; 
            renderGrid(); 
        });

        // --- INPUT UPDATES ---
        function updateGridFromInput() {
            gridState.width = parseFloat(document.getElementById('gridWidth').value);
            gridState.height = parseFloat(document.getElementById('gridHeight').value);
            gridState.spacing = parseFloat(document.getElementById('gridSpacing').value);
            renderGrid();
        }

        function moveGridTo(latlng) {
            gridState.center = latlng;
            centerGrip.setLatLng(latlng);
            renderGrid();
        }

        function resetRotation() {
            gridState.rotation = 0;
            renderGrid();
        }

        function locateUser() {
            map.locate({setView: true, maxZoom: 18});
            map.once('locationfound', e => moveGridTo(e.latlng));
        }

        // --- BOUNDARY DRAWING ---
        let boundaryPoints = [];
        let isBoundaryMode = false;

        function toggleBoundaryMode() {
            isBoundaryMode = !isBoundaryMode;
            const btn = document.getElementById('btn-boundary');
            
            if(isBoundaryMode) {
                btn.classList.add('active');
                btn.innerHTML = 'Finish Drawing';
                map.getContainer().style.cursor = 'crosshair';
                // Disable grip dragging while drawing
                centerGrip.dragging.disable();
                rotateGrip.dragging.disable();
                resizeGrip.dragging.disable();
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '‚úèÔ∏è Draw Boundary';
                map.getContainer().style.cursor = '';
                centerGrip.dragging.enable();
                rotateGrip.dragging.enable();
                resizeGrip.dragging.enable();
            }
        }

        map.on('click', (e) => {
            if(!isBoundaryMode) return;
            boundaryPoints.push(e.latlng);
            drawBoundary();
        });

        map.on('contextmenu', (e) => {
            if(isBoundaryMode && boundaryPoints.length > 0) {
                boundaryPoints.pop();
                drawBoundary();
                L.DomEvent.preventDefault(e);
            }
        });

        function drawBoundary() {
            boundaryLayer.clearLayers();
            if(boundaryPoints.length > 0) {
                L.polygon(boundaryPoints, {color: 'red', weight: 3}).addTo(boundaryLayer);
                boundaryPoints.forEach(p => {
                    L.circleMarker(p, {radius: 3, color: 'red', fillColor: 'white', fillOpacity: 1}).addTo(boundaryLayer);
                });
            }
        }

        // --- DXF EXPORT ---
        function exportDXF() {
            // Convert Center to OSGB
            const osCenter = proj4("EPSG:4326", "EPSG:27700", [gridState.center.lng, gridState.center.lat]);
            
            let dxf = [
                "0", "SECTION", "2", "HEADER", "9", "$ACADVER", "1", "AC1009", "0", "ENDSEC",
                "0", "SECTION", "2", "TABLES", 
                "0", "TABLE", "2", "LAYER", "70", "2",
                "0", "LAYER", "2", "GRID", "70", "0", "62", "5", "6", "CONTINUOUS",
                "0", "LAYER", "2", "BOUNDARY", "70", "0", "62", "1", "6", "CONTINUOUS",
                "0", "ENDTAB", "0", "ENDSEC",
                "0", "SECTION", "2", "ENTITIES"
            ];

            // Transform Helper: Local Meter Offset -> Rotated -> Translated OSGB
            const cos = Math.cos(gridState.rotation);
            const sin = Math.sin(gridState.rotation);

            const transform = (x, y) => {
                const rx = x * cos - y * sin; // Rotate
                const ry = x * sin + y * cos;
                return [osCenter[0] + rx, osCenter[1] + ry]; // Translate
            };

            const addLine = (x1, y1, x2, y2) => {
                const s = transform(x1, y1);
                const e = transform(x2, y2);
                dxf.push("0", "LINE", "8", "GRID", "10", s[0].toFixed(3), "20", s[1].toFixed(3), "11", e[0].toFixed(3), "21", e[1].toFixed(3));
            };

            // Grid Lines
            const w = gridState.width;
            const h = gridState.height;
            const sp = gridState.spacing;

            // Verticals
            for(let x = -w/2; x <= w/2; x += sp) addLine(x, -h/2, x, h/2);
            // Horizontals
            for(let y = -h/2; y <= h/2; y += sp) addLine(-w/2, y, w/2, y);

            // Boundary
            if(boundaryPoints.length > 1) {
                dxf.push("0", "LWPOLYLINE", "8", "BOUNDARY", "90", boundaryPoints.length, "70", "1");
                boundaryPoints.forEach(pt => {
                    const os = proj4("EPSG:4326", "EPSG:27700", [pt.lng, pt.lat]);
                    dxf.push("10", os[0].toFixed(3), "20", os[1].toFixed(3));
                });
            }

            dxf.push("0", "ENDSEC", "0", "EOF");

            const blob = new Blob([dxf.join("\n")], {type: 'application/dxf'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `survey_${Date.now()}.dxf`;
            link.click();
        }

        // Init
        renderGrid();

    </script>
</body>
</html>
