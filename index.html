<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OSGB36(15) 3-Point Rectangle Grid + Boundary → DXF</title>

  <!-- Leaflet -->
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>

  <!-- Geocoder -->
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"/>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <!-- Proj4 + GeoTIFF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.19.0/proj4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>

  <style>
    :root { --pad: 12px; --radius: 16px; }
    html, body { height: 100%; margin: 0; background: #0b0f19; }
    #map { height: 100%; width: 100%; }
    .leaflet-top, .leaflet-bottom { z-index: 10050 !important; }

    .sheet {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      z-index: 9999;
      background: rgba(255,255,255,0.96);
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
      box-shadow: 0 -12px 24px rgba(0,0,0,0.25);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      height: 78vh;
      transform: translateY(44vh);
      transition: transform 180ms ease;
      will-change: transform;

      padding: var(--pad);
      padding-bottom: calc(var(--pad) + env(safe-area-inset-bottom));
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .handle {
      width: 54px; height: 6px;
      background: #d1d5db;
      border-radius: 999px;
      margin: 6px auto 12px auto;
      touch-action: none;
    }
    .sheet.is-collapsed { overflow: hidden; }
    .sheet.is-collapsed .mini,
    .sheet.is-collapsed .status { display: none; }

    .toprow {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .title { font-weight: 900; font-size: 16px; }
    .badge {
      font-size: 12px;
      background: #e5e7eb;
      padding: 4px 10px;
      border-radius: 999px;
      white-space: nowrap;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .btn {
      flex: 1;
      padding: 12px 12px;
      font-size: 15px;
      font-weight: 800;
      border: 0;
      border-radius: 14px;
      background: #111827;
      color: white;
      touch-action: manipulation;
    }
    .btn.secondary { background: #4b5563; }
    .btn.danger { background: #991b1b; }
    .btn:disabled { opacity: 0.55; }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .field {
      background: #f3f4f6;
      border-radius: 14px;
      padding: 10px;
    }
    .field label {
      display: block;
      font-size: 12px;
      color: #374151;
      margin-bottom: 6px;
    }
    .field input[type="number"], .field input[type="text"] {
      width: 100%;
      font-size: 16px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #d1d5db;
      outline: none;
      box-sizing: border-box;
      background: white;
    }

    .toggle {
      display: flex; align-items: center; justify-content: space-between;
      background: #f3f4f6;
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      gap: 12px;
    }
    .toggle span { font-size: 13px; color: #111827; font-weight: 700; }
    .toggle input { transform: scale(1.3); }

    .status {
      margin-top: 10px;
      font-size: 12px;
      color: #111827;
      background: #eef2ff;
      border: 1px solid #c7d2fe;
      padding: 10px;
      border-radius: 14px;
      white-space: pre-wrap;
    }
    .mini {
      margin-top: 8px;
      font-size: 12px;
      color: #374151;
      line-height: 1.35;
    }

    .crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 36px; height: 36px;
      transform: translate(-50%, -50%);
      z-index: 6000;
      pointer-events: none;
      display: none;
    }
    .crosshair:before, .crosshair:after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 1px 4px rgba(0,0,0,0.35);
    }
    .crosshair:before { left: 50%; top: 0; width: 2px; height: 100%; transform: translateX(-50%); }
    .crosshair:after  { top: 50%; left: 0; height: 2px; width: 100%; transform: translateY(-50%); }
    .crosshair .dot {
      position: absolute;
      left: 50%; top: 50%;
      width: 10px; height: 10px;
      border-radius: 999px;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.95);
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }

    .leaflet-control-zoom a { width: 40px; height: 40px; line-height: 40px; font-size: 18px; }
    .leaflet-control-geocoder { max-width: 70vw; }
  </style>
</head>

<body>
  <div id="map"></div>
  <div class="crosshair" id="crosshair"><div class="dot"></div></div>

  <div class="sheet" id="sheet">
    <div class="handle" id="handle" aria-label="Drag to resize"></div>

    <div class="toprow">
      <div class="title">OSGB36(15) 3-Point Grid + Boundary → DXF</div>
      <div class="badge" id="modeBadge">idle</div>
    </div>

    <div class="row">
      <button class="btn" id="rect3Btn">Define rectangle (3 pts)</button>
      <button class="btn secondary" id="gpsBtn">Use GPS</button>
    </div>

    <div class="row">
      <button class="btn secondary" id="drawBoundaryBtn">Draw boundary</button>
      <button class="btn secondary" id="finishBoundaryBtn" disabled>Finish boundary</button>
      <button class="btn danger" id="clearBoundaryBtn" disabled>Clear boundary</button>
    </div>

    <div class="row">
      <button class="btn secondary" id="resetBtn">Reset</button>
      <button class="btn" id="exportBtn" disabled>Export DXF</button>
    </div>

    <div class="toggle">
      <span>Use crosshair (pick from screen centre)</span>
      <input id="useCrosshair" type="checkbox" />
    </div>

    <div class="toggle">
      <span>Export relative to P1 (origin)</span>
      <input id="relativeExport" type="checkbox" />
    </div>

    <div class="grid2">
      <div class="field">
        <label for="gridSpacing">Grid spacing (m)</label>
        <input id="gridSpacing" type="number" min="0.1" step="0.1" value="10" />
      </div>
      <div class="field">
        <label for="layerName">Grid layer (DXF)</label>
        <input id="layerName" type="text" value="GRID" />
      </div>
      <div class="field">
        <label for="boundaryLayerName">Boundary layer (DXF)</label>
        <input id="boundaryLayerName" type="text" value="BOUNDARY" />
      </div>
      <div class="field">
        <label>Rectangle</label>
        <div style="font-size:14px;font-weight:900;" id="rectInfo">Not set</div>
      </div>
    </div>

    <div class="status" id="statusBox">Starting…</div>
    <div class="mini">
      Rectangle: tap P1, tap P2 (length + rotation), tap P3 (width). Grid fills that rectangle.
    </div>
  </div>

<script>
  // ---------------------------
  // Map setup (Satellite)
  // ---------------------------
  const map = L.map('map', { zoomControl: true }).setView([52.2, 0.9], 13);

  L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { maxZoom: 20, attribution: 'Tiles © Esri' }
  ).addTo(map);

  const geocodeControl = L.Control.geocoder({ defaultMarkGeocode: false }).addTo(map);
  geocodeControl.on('markgeocode', (e) => map.fitBounds(e.geocode.bbox));

  // ---------------------------
  // DOM refs
  // ---------------------------
  const statusBox = document.getElementById('statusBox');
  const exportBtn = document.getElementById('exportBtn');
  const modeBadge = document.getElementById('modeBadge');

  window.addEventListener('error', (ev) => {
    statusBox.textContent = 'JS error: ' + (ev.message || ev.error || 'unknown');
  });

  // ---------------------------
  // OSGB36(15) / OSTN15
  // ---------------------------
  const OSTN15_TIFF_URL = 'https://cdn.proj.org/uk_os_OSTN15_NTv2_OSGBtoETRS.tif';
  const EPSG27700_DEF_BASE =
    '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 ' +
    '+x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs +type=crs';

  proj4.defs('EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs +type=crs');
  let ostnReady = false;

  async function loadOSTN15() {
    try {
      statusBox.textContent = 'Loading OSTN15 grid (needs internet)…';
      const tiff = await GeoTIFF.fromUrl(OSTN15_TIFF_URL);
      await proj4.nadgrid('OSTN15_NTv2_OSGBtoETRS', tiff).ready;
      proj4.defs('EPSG:27700', EPSG27700_DEF_BASE + ' +nadgrids=OSTN15_NTv2_OSGBtoETRS');
      ostnReady = true;
      statusBox.textContent = 'OSTN15 loaded ✅ (OSGB36(15) accurate)';
      exportBtn.disabled = false;
    } catch (e) {
      console.error(e);
      statusBox.textContent = 'OSTN15 failed ⚠️ Using fallback (not survey-grade). Host via HTTPS.';
      proj4.defs(
        'EPSG:27700',
        '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 ' +
        '+x_0=400000 +y_0=-100000 +ellps=airy ' +
        '+towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 ' +
        '+units=m +no_defs +type=crs'
      );
      ostnReady = false;
      exportBtn.disabled = false;
    }
  }

  // ---------------------------
  // Helpers
  // ---------------------------
  const useCrosshairEl = document.getElementById('useCrosshair');
  const crosshairEl = document.getElementById('crosshair');
  const gridSpacingEl = document.getElementById('gridSpacing');
  const layerNameEl = document.getElementById('layerName');
  const boundaryLayerNameEl = document.getElementById('boundaryLayerName');
  const relativeExportEl = document.getElementById('relativeExport');
  const rectInfoEl = document.getElementById('rectInfo');

  function crosshairLatLng() { return map.getCenter(); }
  function getPickLatLng(tapLatLng) { return useCrosshairEl.checked ? crosshairLatLng() : tapLatLng; }

  function latLngToEN(latlng) {
    const out = proj4('EPSG:4326', 'EPSG:27700', [latlng.lng, latlng.lat]);
    return { e: out[0], n: out[1] };
  }
  function enToLatLng(e, n) {
    const out = proj4('EPSG:27700', 'EPSG:4326', [e, n]);
    return L.latLng(out[1], out[0]);
  }

  function hypot2(de, dn) { return Math.sqrt(de*de + dn*dn); }

  // ---------------------------
  // Layers
  // ---------------------------
  const gridLayer = L.layerGroup().addTo(map);
  const rectLayer = L.layerGroup().addTo(map);
  const pickLayer = L.layerGroup().addTo(map);

  // Boundary
  const boundaryPointsLayer = L.layerGroup().addTo(map);
  let boundaryLatLngs = [];
  let boundaryPreviewLine = null;

  // ---------------------------
  // Modes / rectangle state
  // ---------------------------
  let mode = 'idle'; // idle | rect3 | boundary

  // 3-point rectangle in EN
  let rectP1 = null; // {e,n}
  let rectP2 = null;
  let rectP3 = null;

  // derived
  let rectLen = 0;
  let rectWid = 0;
  let rectU = null; // unit along length {e,n}
  let rectW = null; // unit perp (to the chosen side) {e,n}
  let rectCornersEN = null; // array of 4 EN corners in order

  function setMode(m) {
    mode = m;
    modeBadge.textContent = m === 'rect3' ? 'pick P1' :
                            m === 'boundary' ? 'boundary draw' : 'idle';
  }

  function clearRectangle() {
    rectP1 = rectP2 = rectP3 = null;
    rectLen = rectWid = 0;
    rectU = rectW = null;
    rectCornersEN = null;
    rectInfoEl.textContent = 'Not set';
    rectLayer.clearLayers();
    gridLayer.clearLayers();
    pickLayer.clearLayers();
  }

  function drawPickPoint(latlng, label) {
    const m = L.circleMarker(latlng, { radius: 8, weight: 2, opacity: 0.95, fillOpacity: 0.25 }).addTo(pickLayer);
    m.bindTooltip(label, { permanent: true, direction: 'top', offset: [0,-8] });
  }

  function computeRectangleFrom3Pts(p1, p2, p3) {
    // p1,p2,p3 are EN objects
    const vE = p2.e - p1.e;
    const vN = p2.n - p1.n;
    const L = hypot2(vE, vN);
    if (L < 0.001) return null;

    const u = { e: vE / L, n: vN / L };            // along baseline
    const w0 = { e: -u.n, n: u.e };                // left perp
    const dE3 = p3.e - p1.e;
    const dN3 = p3.n - p1.n;
    const widthSigned = dE3 * w0.e + dN3 * w0.n;   // projection onto perp
    const W = Math.abs(widthSigned);
    if (W < 0.001) return null;

    // choose side so width is positive in rect local coords
    const w = widthSigned >= 0 ? w0 : { e: -w0.e, n: -w0.n };

    // corners: p1, p2, p2 + w*W, p1 + w*W
    const c1 = { e: p1.e, n: p1.n };
    const c2 = { e: p2.e, n: p2.n };
    const c3 = { e: p2.e + w.e * W, n: p2.n + w.n * W };
    const c4 = { e: p1.e + w.e * W, n: p1.n + w.n * W };

    return { L, W, u, w, corners: [c1, c2, c3, c4] };
  }

  function redrawRectangleAndGrid() {
    rectLayer.clearLayers();
    gridLayer.clearLayers();

    if (!rectCornersEN) return;

    // Draw rectangle outline
    const ring = [...rectCornersEN, rectCornersEN[0]].map(p => enToLatLng(p.e, p.n));
    L.polyline(ring, { weight: 3, opacity: 0.9 }).addTo(rectLayer);

    // Build grid lines inside rectangle in local coords:
    // local origin at P1, x in [0..L] along u, y in [0..W] along w
    const spacing = parseFloat(gridSpacingEl.value);
    if (!(spacing > 0)) return;

    // Snap line positions so border is included
    const nx = Math.max(1, Math.round(rectLen / spacing));
    const ny = Math.max(1, Math.round(rectWid / spacing));
    const sx = rectLen / nx;
    const sy = rectWid / ny;

    const p1 = rectP1; // EN
    const u = rectU;
    const w = rectW;

    function localToEN(x, y) {
      return { e: p1.e + u.e * x + w.e * y, n: p1.n + u.n * x + w.n * y };
    }

    // Vertical-ish lines (parallel to width)
    for (let i = 0; i <= nx; i++) {
      const x = i * sx;
      const a = localToEN(x, 0);
      const b = localToEN(x, rectWid);
      L.polyline([enToLatLng(a.e,a.n), enToLatLng(b.e,b.n)], { weight: 2, opacity: 0.85 }).addTo(gridLayer);
    }

    // Horizontal-ish lines (parallel to length)
    for (let j = 0; j <= ny; j++) {
      const y = j * sy;
      const a = localToEN(0, y);
      const b = localToEN(rectLen, y);
      L.polyline([enToLatLng(a.e,a.n), enToLatLng(b.e,b.n)], { weight: 2, opacity: 0.85 }).addTo(gridLayer);
    }
  }

  // ---------------------------
  // Boundary drawing
  // ---------------------------
  const drawBoundaryBtn = document.getElementById('drawBoundaryBtn');
  const finishBoundaryBtn = document.getElementById('finishBoundaryBtn');
  const clearBoundaryBtn = document.getElementById('clearBoundaryBtn');

  function redrawBoundaryPreview() {
    if (boundaryPreviewLine) boundaryPreviewLine.remove();
    boundaryPointsLayer.clearLayers();

    if (boundaryLatLngs.length === 0) {
      boundaryPreviewLine = null;
      finishBoundaryBtn.disabled = true;
      clearBoundaryBtn.disabled = true;
      return;
    }

    boundaryPreviewLine = L.polyline(boundaryLatLngs, { weight: 3, opacity: 0.9 }).addTo(map);
    boundaryLatLngs.forEach(ll => {
      L.circleMarker(ll, { radius: 5, weight: 2, opacity: 0.9, fillOpacity: 0.2 }).addTo(boundaryPointsLayer);
    });

    finishBoundaryBtn.disabled = boundaryLatLngs.length < 2;
    clearBoundaryBtn.disabled = false;
  }

  // ---------------------------
  // DXF export
  // ---------------------------
  const DXF_COLOR_RED = 1;
  const DXF_COLOR_BLUE = 5;

  function dxfLineEntity(x1, y1, x2, y2, layer, aciColor) {
    return [
      "0","LINE",
      "8", layer,
      "62", String(aciColor),
      "10", x1.toFixed(3),
      "20", y1.toFixed(3),
      "30", "0.000",
      "11", x2.toFixed(3),
      "21", y2.toFixed(3),
      "31", "0.000"
    ].join("\n") + "\n";
  }

  function dxfLWPolyline(pointsXY, layer, aciColor, closed=false) {
    const flag = closed ? 1 : 0;
    let out = "";
    out += "0\nLWPOLYLINE\n";
    out += "8\n" + layer + "\n";
    out += "62\n" + String(aciColor) + "\n";
    out += "90\n" + String(pointsXY.length) + "\n";
    out += "70\n" + String(flag) + "\n";
    for (const p of pointsXY) {
      out += "10\n" + p.x.toFixed(3) + "\n";
      out += "20\n" + p.y.toFixed(3) + "\n";
    }
    return out;
  }

  function exportDXF() {
    if (!rectP1 || !rectCornersEN) { alert("Define the 3-point rectangle first."); return; }

    const spacing = parseFloat(gridSpacingEl.value);
    if (!(spacing > 0)) { alert("Grid spacing must be > 0."); return; }

    const gridLayerName = (layerNameEl.value || "GRID").trim();
    const bndLayerName = (boundaryLayerNameEl.value || "BOUNDARY").trim();
    const rel = !!relativeExportEl.checked;

    const origin = rectP1; // EN
    const u = rectU;
    const w = rectW;
    const L = rectLen;
    const W = rectWid;

    const nx = Math.max(1, Math.round(L / spacing));
    const ny = Math.max(1, Math.round(W / spacing));
    const sx = L / nx;
    const sy = W / ny;

    function localToEN(x, y) {
      return { e: origin.e + u.e * x + w.e * y, n: origin.n + u.n * x + w.n * y };
    }
    function toOut(en) {
      return rel ? { x: en.e - origin.e, y: en.n - origin.n } : { x: en.e, y: en.n };
    }

    let dxf = "";
    dxf += "0\nSECTION\n2\nHEADER\n";
    dxf += "9\n$INSUNITS\n70\n6\n";
    dxf += "0\nENDSEC\n";
    dxf += "0\nSECTION\n2\nENTITIES\n";

    // Grid BLUE (lines inside rectangle)
    for (let i = 0; i <= nx; i++) {
      const x = i * sx;
      const a = toOut(localToEN(x, 0));
      const b = toOut(localToEN(x, W));
      dxf += dxfLineEntity(a.x, a.y, b.x, b.y, gridLayerName, DXF_COLOR_BLUE);
    }
    for (let j = 0; j <= ny; j++) {
      const y = j * sy;
      const a = toOut(localToEN(0, y));
      const b = toOut(localToEN(L, y));
      dxf += dxfLineEntity(a.x, a.y, b.x, b.y, gridLayerName, DXF_COLOR_BLUE);
    }

    // Boundary RED
    if (boundaryLatLngs.length >= 2) {
      const bxy = boundaryLatLngs.map(ll => {
        const en = latLngToEN(ll);
        const o = rel ? { x: en.e - origin.e, y: en.n - origin.n } : { x: en.e, y: en.n };
        return o;
      });
      dxf += dxfLWPolyline(bxy, bndLayerName, DXF_COLOR_RED, false);
    }

    dxf += "0\nENDSEC\n0\nEOF\n";

    const blob = new Blob([dxf], { type: "application/dxf" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.style.display = "none";
    a.rel = "noopener";
    a.target = "_blank";

    const name = `rectgrid_${rel ? "REL_P1" : "OSGB"}_${Math.round(L)}x${Math.round(W)}_${spacing}m.dxf`;
    a.download = name;

    document.body.appendChild(a);
    a.click();
    setTimeout(() => window.open(url, "_blank"), 250);
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 30000);
  }

  // ---------------------------
  // Click handling
  // ---------------------------
  document.getElementById('rect3Btn').addEventListener('click', () => {
    setMode('rect3');
    clearRectangle();
    statusBox.textContent = 'Rectangle mode: pick P1, then P2, then P3.';
    modeBadge.textContent = 'pick P1';
  });

  map.on('click', (e) => {
    const picked = getPickLatLng(e.latlng);

    if (mode === 'boundary') {
      boundaryLatLngs.push(picked);
      redrawBoundaryPreview();
      return;
    }

    if (mode !== 'rect3') return;

    // Rectangle 3-point picking
    const en = latLngToEN(picked);

    if (!rectP1) {
      rectP1 = en;
      pickLayer.clearLayers();
      drawPickPoint(picked, 'P1');
      modeBadge.textContent = 'pick P2';
      statusBox.textContent = 'Picked P1. Now pick P2 (length + rotation).';
      return;
    }

    if (!rectP2) {
      rectP2 = en;
      drawPickPoint(picked, 'P2');
      modeBadge.textContent = 'pick P3';
      statusBox.textContent = 'Picked P2. Now pick P3 (width).';
      return;
    }

    if (!rectP3) {
      rectP3 = en;
      drawPickPoint(picked, 'P3');

      const res = computeRectangleFrom3Pts(rectP1, rectP2, rectP3);
      if (!res) {
        statusBox.textContent = 'Bad rectangle (points too close / width ~0). Try again.';
        clearRectangle();
        modeBadge.textContent = 'pick P1';
        return;
      }

      rectLen = res.L;
      rectWid = res.W;
      rectU = res.u;
      rectW = res.w;
      rectCornersEN = res.corners;

      rectInfoEl.textContent = `${rectLen.toFixed(2)} m × ${rectWid.toFixed(2)} m`;
      statusBox.textContent = `Rectangle set: L=${rectLen.toFixed(2)}m, W=${rectWid.toFixed(2)}m. Grid drawn.`;
      modeBadge.textContent = 'done';

      redrawRectangleAndGrid();
      // stay in rect3 mode in case you want to re-pick with the button
    }
  });

  // ---------------------------
  // Buttons / toggles
  // ---------------------------
  document.getElementById('gpsBtn').addEventListener('click', () => {
    map.locate({ setView: true, maxZoom: 19, enableHighAccuracy: true, timeout: 15000 });
  });

  map.on('locationfound', (e) => {
    if (window._gpsAccuracy) window._gpsAccuracy.remove();
    window._gpsAccuracy = L.circle(e.latlng, {
      radius: e.accuracy,
      weight: 1,
      opacity: 0.6,
      fillOpacity: 0.08
    }).addTo(map);
    statusBox.textContent = `GPS found (±${Math.round(e.accuracy)}m).`;
  });

  map.on('locationerror', (e) => {
    alert("Couldn't get GPS location: " + (e.message || "permission denied / unavailable"));
  });

  document.getElementById('resetBtn').addEventListener('click', () => {
    setMode('idle');
    clearRectangle();

    boundaryLatLngs = [];
    if (boundaryPreviewLine) boundaryPreviewLine.remove();
    boundaryPreviewLine = null;
    boundaryPointsLayer.clearLayers();
    redrawBoundaryPreview();

    statusBox.textContent = 'Reset.';
  });

  exportBtn.addEventListener('click', exportDXF);

  drawBoundaryBtn.addEventListener('click', () => {
    setMode('boundary');
    statusBox.textContent = 'Boundary mode: tap points, then Finish boundary.';
  });

  finishBoundaryBtn.addEventListener('click', () => {
    setMode('idle');
    statusBox.textContent = 'Boundary finished.';
  });

  clearBoundaryBtn.addEventListener('click', () => {
    boundaryLatLngs = [];
    if (boundaryPreviewLine) boundaryPreviewLine.remove();
    boundaryPreviewLine = null;
    boundaryPointsLayer.clearLayers();
    redrawBoundaryPreview();
    statusBox.textContent = 'Boundary cleared.';
  });

  gridSpacingEl.addEventListener('input', () => {
    if (rectCornersEN) redrawRectangleAndGrid();
  });

  useCrosshairEl.addEventListener('change', () => {
    crosshairEl.style.display = useCrosshairEl.checked ? 'block' : 'none';
  });

  // ---------------------------
  // Bottom sheet snapping
  // ---------------------------
  const sheet = document.getElementById('sheet');
  const handle = document.getElementById('handle');
  const snaps = { open: 6, half: 44, closed: 66 };

  let currentSnap = 'half';
  setSheetSnap(currentSnap);

  function setSheetSnap(which) {
    currentSnap = which;
    sheet.style.transform = `translateY(${snaps[which]}vh)`;
    sheet.classList.toggle('is-collapsed', which === 'closed');
  }

  handle.addEventListener('click', () => {
    setSheetSnap(currentSnap === 'closed' ? 'half' : 'closed');
  });

  let dragging = false, startY = 0, startTranslateVh = snaps[currentSnap], hasMoved = false;

  function getTranslateVhFromStyle() {
    const m = sheet.style.transform.match(/translateY\(([-0-9.]+)vh\)/);
    return m ? parseFloat(m[1]) : snaps.half;
  }
  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  handle.addEventListener('pointerdown', (e) => {
    dragging = true;
    hasMoved = false;
    handle.setPointerCapture(e.pointerId);
    sheet.style.transition = 'none';
    startY = e.clientY;
    startTranslateVh = getTranslateVhFromStyle();
  });

  handle.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const dyPx = e.clientY - startY;
    if (Math.abs(dyPx) > 6) hasMoved = true;

    const vhPx = window.innerHeight / 100;
    const dyVh = dyPx / vhPx;

    let next = startTranslateVh + dyVh;
    next = clamp(next, 0, 72);
    sheet.style.transform = `translateY(${next}vh)`;
  });

  handle.addEventListener('pointerup', () => {
    if (!dragging) return;
    dragging = false;
    sheet.style.transition = 'transform 180ms ease';

    if (!hasMoved) return;

    const now = getTranslateVhFromStyle();
    const options = Object.entries(snaps);
    let best = options[0];
    for (const opt of options) {
      if (Math.abs(opt[1] - now) < Math.abs(best[1] - now)) best = opt;
    }
    setSheetSnap(best[0]);
  });

  // Startup
  redrawBoundaryPreview();
  setMode('idle');
  loadOSTN15();
  statusBox.textContent = 'Ready. Search top-right, GPS optional. Tap "Define rectangle".';
</script>
</body>
</html>
