// ---------------------------
// DXF export (Grid BLUE, Shape RED) â€” SAFE VERSION
// - CRLF line endings
// - boundary exported as LINE segments (more compatible)
// - entity count guard
// ---------------------------
const DXF_COLOR_RED = 1;
const DXF_COLOR_BLUE = 5;

const EOL = "\r\n"; // important: CRLF for picky CAD importers

function dxfLineEntity(x1, y1, x2, y2, layer, aciColor) {
  // Ensure finite numbers
  if (![x1,y1,x2,y2].every(Number.isFinite)) return "";
  return [
    "0","LINE",
    "8", layer,
    "62", String(aciColor),
    "10", x1.toFixed(3),
    "20", y1.toFixed(3),
    "30", "0.000",
    "11", x2.toFixed(3),
    "21", y2.toFixed(3),
    "31", "0.000"
  ].join(EOL) + EOL;
}

function exportBoundaryAsLines(pointsXY, layer, aciColor, closed=true) {
  // pointsXY: [{x,y}, ...]
  let out = "";
  if (!pointsXY || pointsXY.length < 2) return out;

  for (let i = 0; i < pointsXY.length - 1; i++) {
    const a = pointsXY[i], b = pointsXY[i+1];
    out += dxfLineEntity(a.x, a.y, b.x, b.y, layer, aciColor);
  }
  if (closed && pointsXY.length >= 3) {
    const a = pointsXY[pointsXY.length - 1];
    const b = pointsXY[0];
    out += dxfLineEntity(a.x, a.y, b.x, b.y, layer, aciColor);
  }
  return out;
}

function exportDXF(){
  const hasRect = (shapeType==='rect' && rectCornersEN);
  const hasPoly = (shapeType==='poly' && polyEN.length>=3);
  if (!hasRect && !hasPoly){ alert('Create a rectangle or polygon first.'); return; }

  resolveGridBasis();

  const spacing = getSpacingMeters();
  if (!Number.isFinite(spacing) || spacing <= 0){ alert('Grid spacing must be > 0'); return; }

  const gridLayerName = (gridLayerEl.value || 'GRID').trim();
  const shpLayerName  = (shapeLayerEl.value || 'BOUNDARY').trim();
  const rel = !!relativeExportEl.checked;

  const clipPoly = hasRect ? rectCornersEN : polyEN;
  exportOriginEN = exportOriginEN || clipPoly[0];
  const origin = exportOriginEN;

  function outXY(p){
    if (!p || !Number.isFinite(p.e) || !Number.isFinite(p.n)) return null;
    return rel ? {x: p.e-origin.e, y: p.n-origin.n} : {x: p.e, y: p.n};
  }

  const b = shapeBoundsEN();
  if (!b){ alert('Shape bounds error'); return; }

  const pad = Math.max(50, spacing*2);
  const minE = b.minE - pad, maxE = b.maxE + pad;
  const minN = b.minN - pad, maxN = b.maxN + pad;

  const gx = gridBasis.gx, gy = gridBasis.gy;

  function toGrid(p){ return {x: dot(p,gx), y: dot(p,gy)}; }
  function fromGrid(x,y){ return add(mul(gx,x), mul(gy,y)); }

  const corners = [
    {e:minE,n:minN},{e:maxE,n:minN},{e:maxE,n:maxN},{e:minE,n:maxN}
  ];
  let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
  for (const c of corners){
    const g = toGrid(c);
    minX=Math.min(minX,g.x); maxX=Math.max(maxX,g.x);
    minY=Math.min(minY,g.y); maxY=Math.max(maxY,g.y);
  }

  const startX = Math.floor(minX/spacing)*spacing;
  const endX   = Math.ceil(maxX/spacing)*spacing;
  const startY = Math.floor(minY/spacing)*spacing;
  const endY   = Math.ceil(maxY/spacing)*spacing;

  const big = hypot2(maxE-minE, maxN-minN) * 2;

  let entities = 0;

  let dxf = "";
  dxf += ["0","SECTION","2","HEADER",
          "9","$INSUNITS","70","6",
          "0","ENDSEC"].join(EOL) + EOL;

  // Add empty TABLES section (some importers like it)
  dxf += ["0","SECTION","2","TABLES","0","ENDSEC"].join(EOL) + EOL;

  dxf += ["0","SECTION","2","ENTITIES"].join(EOL) + EOL;

  // Grid BLUE
  for (let x = startX; x <= endX + 1e-9; x += spacing){
    const A = fromGrid(x, startY - big);
    const B2 = fromGrid(x, endY + big);
    const segs = clipLineToPolygon(A,B2,clipPoly);
    for (const s of segs){
      const a = outXY(s.a), b2 = outXY(s.b);
      if (!a || !b2) continue;
      dxf += dxfLineEntity(a.x,a.y,b2.x,b2.y, gridLayerName, DXF_COLOR_BLUE);
      entities++;
    }
  }
  for (let y = startY; y <= endY + 1e-9; y += spacing){
    const A = fromGrid(startX - big, y);
    const B2 = fromGrid(endX + big, y);
    const segs = clipLineToPolygon(A,B2,clipPoly);
    for (const s of segs){
      const a = outXY(s.a), b2 = outXY(s.b);
      if (!a || !b2) continue;
      dxf += dxfLineEntity(a.x,a.y,b2.x,b2.y, gridLayerName, DXF_COLOR_BLUE);
      entities++;
    }
  }

  // Boundary RED as LINE segments (robust)
  const tol = Math.max(0, parseFloat(simplifyTolEl.value) || 0);

  // Your existing removeNearDuplicates + rdpSimplify are fine; keep them.
  let shp = removeNearDuplicates(clipPoly.slice(), 0.001);

  if (shp.length >= 3){
    // simplify a CLOSED chain, then export without duplicating first vertex
    const closed = shp.concat([shp[0]]);
    const simplified = rdpSimplify(closed, tol);

    // remove last duplicate point (closure)
    const finalPts = simplified.slice(0, -1);
    const ptsXY = finalPts.map(outXY).filter(Boolean);

    dxf += exportBoundaryAsLines(ptsXY, shpLayerName, DXF_COLOR_RED, true);
    entities += ptsXY.length; // approximate
  }

  dxf += ["0","ENDSEC","0","EOF"].join(EOL) + EOL;

  // Guard: warn if huge
  if (entities > 60000) {
    statusBox.textContent =
      `Warning: exporting ~${entities.toLocaleString()} entities.\n` +
      `If CAD hangs, increase spacing or simplify tolerance.`;
  }

  const blob = new Blob([dxf], { type: "application/dxf" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.style.display = "none";
  a.rel = "noopener";
  a.download = `grid_${shapeType}_${rel ? "REL" : "OSGB"}_${spacing.toFixed(3)}m.dxf`;

  document.body.appendChild(a);
  a.click();

  // mobile fallback
  setTimeout(() => window.open(url, "_blank"), 250);

  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 60000);

  statusBox.textContent = `Exported DXF (${spacing.toFixed(3)}m).`;
}
