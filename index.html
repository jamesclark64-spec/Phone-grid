<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>SurveyGrid Pro</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; overflow: hidden; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; z-index: 1; }
        
        /* Floating Controls */
        .ui-panel {
            position: absolute; bottom: 20px; left: 10px; right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            display: flex; flex-direction: column; gap: 10px;
            max-height: 35vh; overflow-y: auto;
        }

        .tool-bar {
            position: absolute; top: 10px; right: 10px;
            z-index: 1000; display: flex; flex-direction: column; gap: 8px;
        }

        button {
            background: #007AFF; color: white; border: none; padding: 12px;
            border-radius: 8px; font-weight: 600; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background 0.2s;
        }
        button:active { transform: scale(0.98); }
        button.active { background: #34C759; }
        
        .input-group { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
        label { font-size: 14px; font-weight: 500; color: #333; }
        input[type="number"] { width: 70px; padding: 8px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px; }

        /* Grips */
        .grip-icon {
            background: white; border: 2px solid #007AFF;
            border-radius: 50%; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .grip-rotate { border-color: #FF9500; cursor: grab; }
        .grip-resize { border-color: #34C759; cursor: nwse-resize; }
        /* Center grip is invisible touch target, visualized by red dot in code */
        .grip-center { background: transparent; border: none; box-shadow: none; cursor: move; }

    </style>
</head>
<body>

    <div id="map"></div>

    <div class="tool-bar">
        <button onclick="locateUser()">üìç GPS</button>
        <button onclick="toggleBoundaryMode()" id="btn-boundary">‚úèÔ∏è Draw Boundary</button>
        <button onclick="resetRotation()">‚¨ÜÔ∏è True North</button>
    </div>

    <div class="ui-panel">
        <div class="input-group">
            <label>Grid Spacing (m)</label>
            <input type="number" id="gridSpacing" value="10" min="1" oninput="scheduleUpdate()">
        </div>
        <div class="input-group">
            <label>Width (m)</label>
            <input type="number" id="gridWidth" value="300" oninput="scheduleUpdate()">
        </div>
        <div class="input-group">
            <label>Height (m)</label>
            <input type="number" id="gridHeight" value="300" oninput="scheduleUpdate()">
        </div>
        <button onclick="exportDXF()">üíæ Export DXF</button>
        <div id="status" style="font-size: 11px; color: #666; text-align: center; margin-top:5px;">
            Drag grips to adjust.
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

    <script>
        // --- SETUP ---
        proj4.defs("EPSG:27700","+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs");
        
        const map = L.map('map').setView([51.505, -0.09], 17);
        
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri', maxZoom: 21
        }).addTo(map);

        L.Control.geocoder({ defaultMarkGeocode: false }).on('markgeocode', function(e) {
            map.setView(e.geocode.center, 18);
            moveGridTo(e.geocode.center);
        }).addTo(map);

        // --- APP STATE ---
        let gridState = {
            center: map.getCenter(),
            width: 300,
            height: 300,
            rotation: 0, 
            spacing: 10
        };

        // Layers
        // interactive: false is KEY so grid lines don't block mouse clicks on the map/grips
        const gridLayer = L.layerGroup().addTo(map);
        const boundaryLayer = L.layerGroup().addTo(map);
        
        // --- GRIPS ---
        // We create them once and move them.
        const gripIconSize = [24, 24]; // Larger touch target
        
        const centerGrip = L.marker(gridState.center, {
            draggable: true, zIndexOffset: 1000,
            icon: L.divIcon({className: 'grip-icon grip-center', html:'<div style="width:10px;height:10px;background:red;border:2px solid white;border-radius:50%;margin:7px;"></div>', iconSize: gripIconSize})
        }).addTo(map);

        const rotateGrip = L.marker(gridState.center, {
            draggable: true, zIndexOffset: 1000,
            icon: L.divIcon({className: 'grip-icon grip-rotate', iconSize: [16,16]})
        }).addTo(map);

        const resizeGrip = L.marker(gridState.center, {
            draggable: true, zIndexOffset: 1000,
            icon: L.divIcon({className: 'grip-icon grip-resize', iconSize: [16,16]})
        }).addTo(map);

        // --- RENDERING LOOP (Performance Optimized) ---
        let isRenderPending = false;

        function scheduleUpdate() {
            // Read inputs safely
            const w = parseFloat(document.getElementById('gridWidth').value);
            const h = parseFloat(document.getElementById('gridHeight').value);
            const s = parseFloat(document.getElementById('gridSpacing').value);

            // Validation to prevent vanishing
            if(w && !isNaN(w)) gridState.width = w;
            if(h && !isNaN(h)) gridState.height = h;
            if(s && !isNaN(s) && s > 0) gridState.spacing = s;

            requestRender();
        }

        function requestRender() {
            if (!isRenderPending) {
                requestAnimationFrame(() => {
                    renderGrid();
                    isRenderPending = false;
                });
                isRenderPending = true;
            }
        }

        function getCorners() {
            const w = gridState.width;
            const h = gridState.height;
            const c = gridState.center;
            const r = gridState.rotation;
            
            // Approximate meter conversions
            const mLat = 1/111132;
            const mLng = 1/(111320 * Math.cos(c.lat * Math.PI/180));
            const cos = Math.cos(r);
            const sin = Math.sin(r);

            // Offsets from center
            const offsets = [
                {x: -w/2, y: h/2}, // TL (Resize)
                {x: w/2, y: h/2},  // TR (Rotate)
                {x: w/2, y: -h/2}, // BR
                {x: -w/2, y: -h/2} // BL
            ];

            return offsets.map(o => {
                const rx = o.x * cos - o.y * sin;
                const ry = o.x * sin + o.y * cos;
                return L.latLng(c.lat + ry * mLat, c.lng + rx * mLng);
            });
        }

        function renderGrid() {
            gridLayer.clearLayers();
            const corners = getCorners();

            // 1. Draw Outline (interactive: false prevents blocking clicks)
            L.polygon(corners, {color: '#007AFF', weight: 2, fill: false, interactive: false}).addTo(gridLayer);

            // 2. Draw Internal Grid
            const stepsX = Math.floor(gridState.width / gridState.spacing);
            const stepsY = Math.floor(gridState.height / gridState.spacing);

            const lerp = (p1, p2, t) => L.latLng(
                p1.lat + (p2.lat - p1.lat) * t,
                p1.lng + (p2.lng - p1.lng) * t
            );

            // Limit lines to prevent browser crash if spacing is too small
            if(stepsX < 200 && stepsY < 200) {
                // Vertical
                for(let i=1; i<=stepsX; i++) {
                    const t = (i * gridState.spacing) / gridState.width;
                    const p1 = lerp(corners[3], corners[2], t);
                    const p2 = lerp(corners[0], corners[1], t);
                    L.polyline([p1, p2], {color: '#007AFF', weight: 1, opacity: 0.4, interactive: false}).addTo(gridLayer);
                }
                // Horizontal
                for(let i=1; i<=stepsY; i++) {
                    const t = (i * gridState.spacing) / gridState.height;
                    const p1 = lerp(corners[3], corners[0], t);
                    const p2 = lerp(corners[2], corners[1], t);
                    L.polyline([p1, p2], {color: '#007AFF', weight: 1, opacity: 0.4, interactive: false}).addTo(gridLayer);
                }
            }

            // 3. Move Grips (Only if not being dragged by user)
            // This prevents "fighting" the mouse cursor
            if(!centerGrip._dragging) centerGrip.setLatLng(gridState.center);
            if(!rotateGrip._dragging) rotateGrip.setLatLng(corners[1]); // TR
            if(!resizeGrip._dragging) resizeGrip.setLatLng(corners[0]); // TL
        }

        // --- DRAG LOGIC ---
        // Flags to track active dragging
        centerGrip.on('dragstart', () => { centerGrip._dragging = true; });
        centerGrip.on('drag', (e) => {
            gridState.center = e.latlng;
            requestRender();
        });
        centerGrip.on('dragend', (e) => { 
            centerGrip._dragging = false; 
            gridState.center = e.latlng;
            requestRender();
        });

        rotateGrip.on('dragstart', () => { rotateGrip._dragging = true; });
        rotateGrip.on('drag', (e) => {
            const centerPt = map.latLngToLayerPoint(gridState.center);
            const mousePt = map.latLngToLayerPoint(e.latlng);
            const dx = mousePt.x - centerPt.x;
            const dy = mousePt.y - centerPt.y;
            // Calculate angle relative to horizontal, corrected for TR corner offset (-45deg)
            gridState.rotation = Math.atan2(dy, dx) + (Math.PI/4);
            requestRender();
        });
        rotateGrip.on('dragend', () => { 
            rotateGrip._dragging = false; 
            requestRender(); 
        });

        resizeGrip.on('dragstart', () => { resizeGrip._dragging = true; });
        resizeGrip.on('drag', (e) => {
            const dist = map.distance(gridState.center, e.latlng);
            const size = Math.max(10, Math.round(dist * 1.414)); // Min size 10m
            gridState.width = size;
            gridState.height = size;
            
            // Sync inputs (optional, maybe skip during drag for speed)
            document.getElementById('gridWidth').value = size;
            document.getElementById('gridHeight').value = size;
            
            requestRender();
        });
        resizeGrip.on('dragend', () => { 
            resizeGrip._dragging = false; 
            requestRender(); 
        });


        // --- UTILS & BOUNDARY ---
        function moveGridTo(latlng) {
            gridState.center = latlng;
            requestRender();
        }

        function resetRotation() {
            gridState.rotation = 0;
            requestRender();
        }

        function locateUser() {
            map.locate({setView: true, maxZoom: 18});
            map.once('locationfound', e => moveGridTo(e.latlng));
        }

        let isBoundaryMode = false;
        let boundaryPoints = [];

        function toggleBoundaryMode() {
            isBoundaryMode = !isBoundaryMode;
            const btn = document.getElementById('btn-boundary');
            if(isBoundaryMode) {
                btn.classList.add('active');
                btn.innerText = 'Finish Drawing';
                map.getContainer().style.cursor = 'crosshair';
                // Hide grips while drawing to avoid clutter
                centerGrip.setOpacity(0); rotateGrip.setOpacity(0); resizeGrip.setOpacity(0);
            } else {
                btn.classList.remove('active');
                btn.innerText = '‚úèÔ∏è Draw Boundary';
                map.getContainer().style.cursor = '';
                centerGrip.setOpacity(1); rotateGrip.setOpacity(1); resizeGrip.setOpacity(1);
            }
        }

        map.on('click', (e) => {
            if(!isBoundaryMode) return;
            boundaryPoints.push(e.latlng);
            renderBoundary();
        });

        map.on('contextmenu', (e) => {
            if(isBoundaryMode && boundaryPoints.length > 0) {
                boundaryPoints.pop();
                renderBoundary();
                L.DomEvent.preventDefault(e);
            }
        });

        function renderBoundary() {
            boundaryLayer.clearLayers();
            if(boundaryPoints.length > 0) {
                L.polygon(boundaryPoints, {color: 'red', weight: 3}).addTo(boundaryLayer);
                boundaryPoints.forEach(p => {
                    L.circleMarker(p, {radius: 4, color: 'red', fillColor: 'white', fillOpacity: 1}).addTo(boundaryLayer);
                });
            }
        }

        // --- EXPORT DXF ---
        function exportDXF() {
            const osCenter = proj4("EPSG:4326", "EPSG:27700", [gridState.center.lng, gridState.center.lat]);
            let dxf = [
                "0", "SECTION", "2", "HEADER", "9", "$ACADVER", "1", "AC1009", "0", "ENDSEC",
                "0", "SECTION", "2", "TABLES", 
                "0", "TABLE", "2", "LAYER", "70", "2",
                "0", "LAYER", "2", "GRID", "70", "0", "62", "5", "6", "CONTINUOUS",
                "0", "LAYER", "2", "BOUNDARY", "70", "0", "62", "1", "6", "CONTINUOUS",
                "0", "ENDTAB", "0", "ENDSEC",
                "0", "SECTION", "2", "ENTITIES"
            ];

            const cos = Math.cos(gridState.rotation);
            const sin = Math.sin(gridState.rotation);

            const transform = (x, y) => {
                const rx = x * cos - y * sin;
                const ry = x * sin + y * cos;
                return [osCenter[0] + rx, osCenter[1] + ry];
            };

            const addLine = (x1, y1, x2, y2) => {
                const s = transform(x1, y1);
                const e = transform(x2, y2);
                dxf.push("0", "LINE", "8", "GRID", "10", s[0].toFixed(3), "20", s[1].toFixed(3), "11", e[0].toFixed(3), "21", e[1].toFixed(3));
            };

            const w = gridState.width;
            const h = gridState.height;
            const sp = gridState.spacing;
            
            for(let x = -w/2; x <= w/2; x += sp) addLine(x, -h/2, x, h/2);
            for(let y = -h/2; y <= h/2; y += sp) addLine(-w/2, y, w/2, y);

            if(boundaryPoints.length > 1) {
                dxf.push("0", "LWPOLYLINE", "8", "BOUNDARY", "90", boundaryPoints.length, "70", "1");
                boundaryPoints.forEach(pt => {
                    const os = proj4("EPSG:4326", "EPSG:27700", [pt.lng, pt.lat]);
                    dxf.push("10", os[0].toFixed(3), "20", os[1].toFixed(3));
                });
            }

            dxf.push("0", "ENDSEC", "0", "EOF");
            const blob = new Blob([dxf.join("\n")], {type: 'application/dxf'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `survey_${Date.now()}.dxf`;
            link.click();
        }

        // Initialize
        requestRender();

    </script>
</body>
</html>
