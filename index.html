<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>SurveyGrid Pro (Stable)</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; overflow: hidden; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; z-index: 1; }
        
        .ui-panel {
            position: absolute; bottom: 20px; left: 10px; right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            display: flex; flex-direction: column; gap: 10px;
            max-height: 40vh; overflow-y: auto;
        }

        .tool-bar {
            position: absolute; top: 10px; right: 10px;
            z-index: 1000; display: flex; flex-direction: column; gap: 8px;
        }

        button {
            background: #007AFF; color: white; border: none; padding: 12px;
            border-radius: 8px; font-weight: 600; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        button.active { background: #34C759; }

        .input-group { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
        label { font-size: 14px; font-weight: 500; color: #333; }
        input[type="number"] { width: 70px; padding: 8px; border: 1px solid #ccc; border-radius: 6px; }

        /* Robust Grip Styles */
        .grip-icon {
            background: white; border: 3px solid #007AFF;
            border-radius: 50%; box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            transition: transform 0.1s;
        }
        .grip-center { background: rgba(255, 255, 255, 0.8); border: 2px solid red; cursor: move; }
        .grip-rotate { border-color: #FF9500; cursor: grab; }
        .grip-resize { border-color: #34C759; cursor: nwse-resize; }
        
        /* Visual feedback when dragging */
        .leaflet-dragging .grip-icon { transform: scale(1.2); }

    </style>
</head>
<body>

    <div id="map"></div>

    <div class="tool-bar">
        <button onclick="locateUser()">üìç GPS</button>
        <button onclick="toggleBoundaryMode()" id="btn-boundary">‚úèÔ∏è Draw Boundary</button>
        <button onclick="resetRotation()">‚¨ÜÔ∏è True North</button>
    </div>

    <div class="ui-panel">
        <div class="input-group">
            <label>Grid Spacing (m)</label>
            <input type="number" id="gridSpacing" value="10" onchange="commitGridUpdate()">
        </div>
        <div class="input-group">
            <label>Width (m)</label>
            <input type="number" id="gridWidth" value="300" onchange="commitGridUpdate()">
        </div>
        <div class="input-group">
            <label>Height (m)</label>
            <input type="number" id="gridHeight" value="300" onchange="commitGridUpdate()">
        </div>
        <button onclick="exportDXF()">üíæ Export DXF</button>
        <div id="status" style="font-size: 11px; color: #666; text-align: center; margin-top:5px;">
            Drag grips. Grid updates on release.
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

    <script>
        // --- 1. SETUP ---
        proj4.defs("EPSG:27700","+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs");
        
        const map = L.map('map').setView([51.505, -0.09], 16);
        
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri', maxZoom: 21
        }).addTo(map);

        L.Control.geocoder({ defaultMarkGeocode: false }).on('markgeocode', function(e) {
            map.setView(e.geocode.center, 18);
            moveGridTo(e.geocode.center);
        }).addTo(map);

        // --- 2. LAYERS ---
        const gridLayer = L.layerGroup().addTo(map);     // The complex grid lines
        const ghostLayer = L.layerGroup().addTo(map);    // The simple box shown while dragging
        const boundaryLayer = L.layerGroup().addTo(map); 
        
        let gridState = {
            center: map.getCenter(),
            width: 300,
            height: 300,
            rotation: 0, 
            spacing: 10
        };

        // --- 3. GRIP CREATION ---
        const gripSize = [24, 24]; // Big easy targets
        
        const centerGrip = L.marker(gridState.center, {
            draggable: true, autoPan: false, zIndexOffset: 2000,
            icon: L.divIcon({className: 'grip-icon grip-center', html:'<div style="width:6px;height:6px;background:red;border-radius:50%;margin:9px;"></div>', iconSize: gripSize})
        }).addTo(map);

        const rotateGrip = L.marker(gridState.center, {
            draggable: true, autoPan: false, zIndexOffset: 2000,
            icon: L.divIcon({className: 'grip-icon grip-rotate', iconSize: [20,20]})
        }).addTo(map);

        const resizeGrip = L.marker(gridState.center, {
            draggable: true, autoPan: false, zIndexOffset: 2000,
            icon: L.divIcon({className: 'grip-icon grip-resize', iconSize: [20,20]})
        }).addTo(map);


        // --- 4. DRAG HANDLERS (The Fix) ---

        // Helper: Calculate corners based on current state
        function getComputedCorners(center, w, h, rot) {
            const mLat = 1/111132;
            const mLng = 1/(111320 * Math.cos(center.lat * Math.PI/180));
            const cos = Math.cos(rot);
            const sin = Math.sin(rot);

            const offsets = [
                {x: -w/2, y: h/2}, // TL (Resize)
                {x: w/2, y: h/2},  // TR (Rotate)
                {x: w/2, y: -h/2}, // BR
                {x: -w/2, y: -h/2} // BL
            ];

            return offsets.map(o => {
                const rx = o.x * cos - o.y * sin;
                const ry = o.x * sin + o.y * cos;
                return L.latLng(center.lat + ry * mLat, center.lng + rx * mLng);
            });
        }

        // --- A. CENTER DRAG ---
        centerGrip.on('dragstart', () => {
            map.dragging.disable(); // Lock map
            gridLayer.clearLayers(); // Hide heavy grid
            renderGhost(gridState.center, gridState.width, gridState.height, gridState.rotation);
        });
        
        centerGrip.on('drag', (e) => {
            // Just move the ghost box, don't do math
            renderGhost(e.latlng, gridState.width, gridState.height, gridState.rotation);
            // Move other grips along visually
            updateGripPositions(e.latlng, gridState.width, gridState.height, gridState.rotation);
        });

        centerGrip.on('dragend', (e) => {
            map.dragging.enable(); // Unlock map
            gridState.center = e.latlng;
            commitGridUpdate(); // Draw full grid
        });

        // --- B. ROTATE DRAG (Top Right) ---
        rotateGrip.on('dragstart', () => {
            map.dragging.disable();
            gridLayer.clearLayers();
            renderGhost(gridState.center, gridState.width, gridState.height, gridState.rotation);
        });

        rotateGrip.on('drag', (e) => {
            const centerPt = map.latLngToLayerPoint(gridState.center);
            const mousePt = map.latLngToLayerPoint(e.latlng);
            
            // Calculate angle
            const dx = mousePt.x - centerPt.x;
            const dy = mousePt.y - centerPt.y;
            // Angle correction: TR corner is naturally at -45deg (top right)
            let newRotation = Math.atan2(dy, dx) + (Math.PI/4);
            
            // Update Ghost only
            renderGhost(gridState.center, gridState.width, gridState.height, newRotation);
            
            // We store this temporarily in the object so resize grip follows correctly
            gridState.rotation = newRotation; 
        });

        rotateGrip.on('dragend', () => {
            map.dragging.enable();
            commitGridUpdate();
        });

        // --- C. RESIZE DRAG (Top Left) ---
        resizeGrip.on('dragstart', () => {
            map.dragging.disable();
            gridLayer.clearLayers();
            renderGhost(gridState.center, gridState.width, gridState.height, gridState.rotation);
        });

        resizeGrip.on('drag', (e) => {
            const dist = map.distance(gridState.center, e.latlng);
            const newSize = Math.max(10, dist * 1.414); // Square approx
            
            // Update Ghost
            renderGhost(gridState.center, newSize, newSize, gridState.rotation);
            
            // Store temp
            gridState.width = newSize;
            gridState.height = newSize;
        });

        resizeGrip.on('dragend', () => {
            map.dragging.enable();
            // Update Inputs
            document.getElementById('gridWidth').value = Math.round(gridState.width);
            document.getElementById('gridHeight').value = Math.round(gridState.height);
            commitGridUpdate();
        });


        // --- 5. RENDERING LOGIC ---

        // Fast render (Outline only)
        function renderGhost(center, w, h, rot) {
            ghostLayer.clearLayers();
            const corners = getComputedCorners(center, w, h, rot);
            
            L.polygon(corners, {
                color: '#ff9500', weight: 2, dashArray: '5, 5', fill: false
            }).addTo(ghostLayer);

            // Keep grips attached to corners visually
            // Note: We don't setLatLng on the grip being dragged (Leaflet does that),
            // but we must move the *other* grips.
            if(!rotateGrip._dragging) rotateGrip.setLatLng(corners[1]); // TR
            if(!resizeGrip._dragging) resizeGrip.setLatLng(corners[0]); // TL
            if(!centerGrip._dragging) centerGrip.setLatLng(center);
        }

        // Slow render (Full Grid) - Called only on DragEnd
        function commitGridUpdate() {
            // Read inputs in case they changed manually
            gridState.spacing = parseFloat(document.getElementById('gridSpacing').value);
            gridState.width = parseFloat(document.getElementById('gridWidth').value);
            gridState.height = parseFloat(document.getElementById('gridHeight').value);

            ghostLayer.clearLayers();
            gridLayer.clearLayers();

            const corners = getComputedCorners(gridState.center, gridState.width, gridState.height, gridState.rotation);

            // 1. Outline
            L.polygon(corners, {color: '#007AFF', weight: 3, fill: false, interactive: false}).addTo(gridLayer);

            // 2. Internal Lines (The heavy part)
            const w = gridState.width;
            const h = gridState.height;
            const s = gridState.spacing;
            
            // Limit checks
            if(s <= 0.5) return; // Prevent crash on 0 spacing
            
            // Lerp helper
            const lerp = (p1, p2, t) => L.latLng(p1.lat + (p2.lat - p1.lat)*t, p1.lng + (p2.lng - p1.lng)*t);

            const stepsX = Math.floor(w/s);
            const stepsY = Math.floor(h/s);
            
            // Cap at 300 lines to prevent browser freeze
            if(stepsX > 300 || stepsY > 300) {
                alert("Grid too dense to display. Export will still work.");
            } else {
                for(let i=1; i<=stepsX; i++) {
                    let t = (i*s)/w;
                    L.polyline([lerp(corners[3], corners[2], t), lerp(corners[0], corners[1], t)], 
                        {color: '#007AFF', weight: 1, opacity: 0.4, interactive: false}).addTo(gridLayer);
                }
                for(let i=1; i<=stepsY; i++) {
                    let t = (i*s)/h;
                    L.polyline([lerp(corners[3], corners[0], t), lerp(corners[2], corners[1], t)], 
                        {color: '#007AFF', weight: 1, opacity: 0.4, interactive: false}).addTo(gridLayer);
                }
            }

            // Ensure grips are in final correct spots
            updateGripPositions(gridState.center, w, h, gridState.rotation);
        }

        function updateGripPositions(c, w, h, r) {
            const corners = getComputedCorners(c, w, h, r);
            if(!rotateGrip._dragging) rotateGrip.setLatLng(corners[1]);
            if(!resizeGrip._dragging) resizeGrip.setLatLng(corners[0]);
            if(!centerGrip._dragging) centerGrip.setLatLng(c);
        }


        // --- 6. UTILITIES ---
        function moveGridTo(latlng) {
            gridState.center = latlng;
            commitGridUpdate();
        }

        function resetRotation() {
            gridState.rotation = 0;
            commitGridUpdate();
        }

        function locateUser() {
            map.locate({setView: true, maxZoom: 18});
            map.once('locationfound', e => moveGridTo(e.latlng));
        }

        // --- 7. BOUNDARY TOOL ---
        let isBoundaryMode = false;
        let boundaryPoints = [];

        function toggleBoundaryMode() {
            isBoundaryMode = !isBoundaryMode;
            const btn = document.getElementById('btn-boundary');
            
            if(isBoundaryMode) {
                btn.classList.add('active');
                btn.innerText = 'Finish Drawing';
                map.getContainer().style.cursor = 'crosshair';
                // Hide grips
                centerGrip.setOpacity(0); rotateGrip.setOpacity(0); resizeGrip.setOpacity(0);
            } else {
                btn.classList.remove('active');
                btn.innerText = '‚úèÔ∏è Draw Boundary';
                map.getContainer().style.cursor = '';
                centerGrip.setOpacity(1); rotateGrip.setOpacity(1); resizeGrip.setOpacity(1);
            }
        }

        map.on('click', (e) => {
            if(!isBoundaryMode) return;
            boundaryPoints.push(e.latlng);
            renderBoundary();
        });
        
        map.on('contextmenu', (e) => { // Right click undo
            if(isBoundaryMode && boundaryPoints.length > 0) {
                boundaryPoints.pop();
                renderBoundary();
                L.DomEvent.preventDefault(e);
            }
        });

        function renderBoundary() {
            boundaryLayer.clearLayers();
            if(boundaryPoints.length > 0) {
                L.polygon(boundaryPoints, {color: 'red', weight: 3}).addTo(boundaryLayer);
                boundaryPoints.forEach(p => {
                    L.circleMarker(p, {radius: 4, color: 'red', fillColor: 'white', fillOpacity: 1}).addTo(boundaryLayer);
                });
            }
        }

        // --- 8. EXPORT DXF ---
        function exportDXF() {
            const osCenter = proj4("EPSG:4326", "EPSG:27700", [gridState.center.lng, gridState.center.lat]);
            let dxf = [
                "0", "SECTION", "2", "HEADER", "9", "$ACADVER", "1", "AC1009", "0", "ENDSEC",
                "0", "SECTION", "2", "TABLES", 
                "0", "TABLE", "2", "LAYER", "70", "2",
                "0", "LAYER", "2", "GRID", "70", "0", "62", "5", "6", "CONTINUOUS",
                "0", "LAYER", "2", "BOUNDARY", "70", "0", "62", "1", "6", "CONTINUOUS",
                "0", "ENDTAB", "0", "ENDSEC",
                "0", "SECTION", "2", "ENTITIES"
            ];

            const cos = Math.cos(gridState.rotation);
            const sin = Math.sin(gridState.rotation);

            const transform = (x, y) => {
                const rx = x * cos - y * sin;
                const ry = x * sin + y * cos;
                return [osCenter[0] + rx, osCenter[1] + ry];
            };

            const addLine = (x1, y1, x2, y2) => {
                const s = transform(x1, y1);
                const e = transform(x2, y2);
                dxf.push("0", "LINE", "8", "GRID", "10", s[0].toFixed(3), "20", s[1].toFixed(3), "11", e[0].toFixed(3), "21", e[1].toFixed(3));
            };

            const w = gridState.width;
            const h = gridState.height;
            const sp = gridState.spacing;
            
            for(let x = -w/2; x <= w/2; x += sp) addLine(x, -h/2, x, h/2);
            for(let y = -h/2; y <= h/2; y += sp) addLine(-w/2, y, w/2, y);

            if(boundaryPoints.length > 1) {
                dxf.push("0", "LWPOLYLINE", "8", "BOUNDARY", "90", boundaryPoints.length, "70", "1");
                boundaryPoints.forEach(pt => {
                    const os = proj4("EPSG:4326", "EPSG:27700", [pt.lng, pt.lat]);
                    dxf.push("10", os[0].toFixed(3), "20", os[1].toFixed(3));
                });
            }

            dxf.push("0", "ENDSEC", "0", "EOF");
            const blob = new Blob([dxf.join("\n")], {type: 'application/dxf'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `survey_${Date.now()}.dxf`;
            link.click();
        }

        // Init
        commitGridUpdate();

    </script>
</body>
</html>
